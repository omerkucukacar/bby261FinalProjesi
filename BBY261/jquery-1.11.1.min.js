/ *! jQuery v1.11.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license * /
! function (a, b) {"nesne" == typeof modülü && "object" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a .document) yeni Hata at ("jQuery, belgeli bir pencere gerektirir"); b (a)} döndürün: b (a)} ("tanımsız"! = pencerenin tipini yazın: this, function (a, b) { var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = { }, l = "1.11.1", m = işlevi (a, b) {yeni m.fn.init (a, b) döndürün}, n = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, o = / ^ - ms - /, p = / - ([\ da-z]) / gi, q = fonksiyon (a, b) {return b.toUpperCase ()} ; m.fn = m.prototype = {jquery: l, yapıcı: m, seçici: "", uzunluk: 0, toArray: function () {return d.call (this)}, get: function (a) {return null! = a? 0> a? this [a + this.length]: this [a]: d.call (this)}, pushStack: function (a) {var b = m.merge (this.constructor () , a), return b.prevObject = bu, b.bağlam = this.context, b}, her: function (a, b) {return m.each (this, a, b)}, map: function (a) {return this.pushStack (m.map (this, işlevi) (b, c) {return a.call (b, c, b)}))}, dilim: function () {return this.pushStack (d.apply (this, argümanlar)))}, önce: function () { this.eq (0)}, last: function () {döndür this this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + (0> a? b: 0); this.pushStack (c> = 0 && b> c? [This [c]]: [])}, end: function () {return this.prevObject || this.constructor (null)}, bas: f , sort: c.sort, splice: c.splice}, m.extend = m.fn.extend = function () {var a, b, c, d, e, f, g = argümanlar [0] || { }, h = 1, i = arguments.length, j =! 1; for ("boolean" == g && (j = g, g = argümanlar [h] || {}, h ++), "object" == typeof g || m.isFunction (g) || (g = {}), h === i && (g = this, h -); i> h; h ++) eğer (null! = (e = arguments [ h])) (e) deki a = g [d], c = e [d], g! == c && (j && c && (m.? İsPlainObject (c) '|| (b = m.isArray (c))) (? B (b = 1 olduğunda, m = bir && m.isArray (a): []): Rf = bir && m.isPlainObject: (a) a: {}, g [d] = m.saat (j, f, c)): void 0! == c && (g [d] = c)); dönüş g}, m.extend ({expando: "jQuery" + (l + Math.random ()). değiştir (/ \ D / g, ""), isReady:! 0, error: function (a) {yeni hata at (a)}, noop: function ( ) {} isFunction: olan (a) {dönüş "işlev" === m.type (a)}, isArray: Array.isArray || olan (a) {dönüş "dizi" === m.type (a )}, isWindow: function (a) {return null! = a && a == a.window}, isNumeric: function (a) {return! m.isArray (a) && a-parseFloat (a)> = 0}, isEmptyObject: function (a) {var b; (a'daki b) için return! 1; return! 0}, isPlainObject: function (a) {var b; if (! a || "object"! == m.type (a ) || a.nodeType || m.isWindow (a)) return 1;! try {if (a.constructor && j.call (a, "kurucu") && j.call (a.constructor!.prototip, "isPrototypeOf")) return! 1} catch (c) {return! 1} eğer (k.ownLast) (b in a) dönüşü için j.call (a, b); (b in a); void 0 === b || j.call (a, b)}, şunu yazın: function (a) {return null == a? a + "": "nesne" == typeof a || "function" == typeof a? h [i.call (a)] || "nesne": a tipi, globalEval: function (b) {b && m.trim (b) && (a.execScript || function (b) {a.eval. call (a, b)}) (b)}, camelCase: function (a) {return a.replace (o, "ms -"). change (p, q)}, nodeName: function (a, b) { Döndür a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, her biri: function (a, b, c) {var d, e = 0, f = a.length, g = r (a) ; (c) {if (g) {((; f> e; e ++) için ise (d = b.apply (a [e], c), d ===! 1) break} (e in a) eğer (d = b.apply (a [e], c), d ===! 1) break} else ise (g) {için ((; f> e; e ++)) ise (d = b.call ( a [e], e, a [e]), d ===! 1) break} else (e in a) ise (d = b.call (a [e], e, a [e]), ! d === 1) break;a} dönüş, trim: function (a) {return null == a? "" :( a + ""). değiştir (n, "")}, makeArray: function (a, b) {var c = b || []; return null! = a && (r (Nesne (a))? m.merge (c, "string" == typeof a? [a]: a): f.call (c, a)), c} , inArray: function (a, b, c) {var d; eğer (b) {eğer (g), g.call (b, a, c) döndürür; (d = b.length için, c = c? 0> c? Math.max (0, d + c): c: 0; d> c; c ++) eğer ((b &&b [c] === a) içinde c) return c} return-1}, birleştirme: function (a, b) {var c = + b. uzunluğu, d = 0, e = a. uzunluğu; (c> d) a [e ++] = b [d ++]; eğer (c! == c) iken (geçersiz 0! == b [d]) a [e ++] = b [d ++]; döndür, a.length = e, a}, grep: function (a, b, c) {için (var d, e = [], f = 0, g = a. Uzunluk, h =! C; g> f; f ++) d =! B (a [f], f), d! == h && e.push (a [f]); dönüş e}, map: fonksiyon (a, b, c) {var d, f = 0, g = a.uzunluk, h = r (a), i = []; eğer (h) için (; g> f; f ++) d = b (a [f], f, c), null! = d && i.push (d); (a için f) yerine d = b (a [f], f, c), null! = d &&..push (d); iadesi yerine getirme ([], i)}, kılavuz: 1,proxy: function (a, b) {var c, e, f; "string" döndür "== b && (f = a [b], b = a, a = f), m.isFunction (a)? (c = d.call (bağımsız değişkenler, 2), e = function () {return a.apply (b || this, c.concat (d.call (bağımsız değişkenler)))}}, e.guid = a.guid = a. guid || m.guid ++, e): void 0}, şimdi: function () {return + new Date}, destek: k}), m.each ("Boolean Sayı Dizesi İşlev Dizin Tarihi RegExp Nesne Hatası". ""), işlev (a, b) {h ["[nesne" + b + "]"] = b.toLowerCase ()}); işlev r (a) {var b = a.length, c = m.type ?! (a); return "fonksiyonu" === c || m.isWindow (a) ?! 1: 1 === a.nodeType && b 0: "dizi" === || 0 === b c | | "sayı" == a & b> 0 && b-1 'in a} var s = işlevi (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "cızırtılı" + - yeni Tarih, v = a.document, w = 0, x = 0, y = gb (), z = gb (), A = gb (), B = işlev (a, b) {return a === b && (l =! 0), 0}, C = ""Tanımsız, D = 1 << 31 E = {}. HasOwnProperty, K = [], G = F.pop, H = F.push, J = F.push, J = F.slice, K = F. indexOf || function (a) {için (var b = 0, c = this.length; c> b; b ++) eğer (bu [b] === a) b döndürün; return-1}, L = "kontrol edildi | seçilen | eşzamansız | otofokus | otomatik oynatma | kontrol | erteleme | devre | gizli | ismap | döngü | birden | açık | salt okunur | gerekli | kapsama "E =" [\\ x20 \\ t \\ r \\ n \\ f] "N = "(?:. \\\\ | [\\ w] | [^ \\ x00 - \\ xa0]) +", O = N.replace ( ""," ağırlık # w "), p =" \\ [ "+ M +" * ( "+ N +") (?: "+ M +" * ([* ^ $ | ~] =!?) "+ M +" * (?: '( (?:. \\\\ | [^ \\\\ ']) *)' | \ "((:?. \\\\ | [^ \\\\\"]) *) \ "| ( "+ O +")) |) "+ M +" * \\] "Q = ":(" + N +") (: \\ ((( '((:?. \\\\ | [^ \ \\\ ']) *)' | \ "((:?. \\\\ | [^ \\\\\"]) *) \ ") | ((:?. \\\\ | [^ \\\\ () [\\]] | "+ P +") *) |. *) \\) |) ", R = yeni RegExp ("^ "+ M +" + | ((?: ^ | [^ \\\\]] (?: \\\.) *) "+ M +" + $ "," g "), S = yeni RegExp ( "^" + M + "*," + M + "*"), T = yeni RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), U = yeni RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\ "", "g"), V = yeni RegExp (Q), W = yeni RegExp ("^" + O + "$"), X = {ID: yeni RegExp ("^ # (" + N + ")"), SINIF: yeni RegExp ("^ \\. (" + N + ")"), ETİKETİ: yeni RegExp ("^ (" + N.replace ("w", "w *") + ")"), ATTR: yeni RegExp ("^" + P), PSEUDO: yeni RegExp ("^" + Q), ÇOCUK: yeni RegExp ("^ :( sadece | ilk | son | en son | en son | en son) - (çocuk | türünden) (?: \\ (" + M + "* (çift | tek | (( [+ -] |) (\\ d *) n |) "+ M +" * (([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\? ) |)", "i"),bool: yeni RegExp ("^ (?:" + L + ") $", "i"), needsContext: yeni RegExp ("^" + M + "* [> + ~] |: (hatta | odd | eq | gt | lt | ilk | | inci) son (:? \\ ( "+ M +" * ((: - \\ d) \\ d *) "+ M +" * \\) |) (= [^? -] | $)", "i")} Y = / ^ (?: giriş | seçme | metinalanı | düğmesi) $ / i, Z = / ^ s \ d $ / i $ = / ^ [^ { ] + \ {\ s * \ [yerel \ w /, _ = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ab = / [+ ~] /, bb = / '| \\ / g, cb = yeni RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "? | (" + M + ") |.)", "İg"), db = işlevi (a, b, c) {var d = "0x" + b-65536; dönüş d! == d || c? B: 0> d String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 ge | 56320)}; deneyin {I.apply (F = J.call (v.childNodes), v.childNodes), K [v.childNodes.length] .nodeType} mandalı (eb) {I = {geçerlidir: F.length fonksiyonu (a, b) {H.apply (a, J.call (b))}: olan (a , b) {var c = a. uzunluğu, d = 0; süre (a [c ++] = b [d ++]); a.uzunluk = c-1}}} işlevi fb (a, b, d, e) {var f, h, j, k, l, o, r, s, w, x; if ((b? b.ownerDocument | | b: v)! == n && m (b), b = b || n, d = d || [] ,! a || a} "string"! = a) typ d; eğer (1! == ( ! k = b.nodeType) && 9 == k) [] dönüş, eğer (s && e) {(f = _ exec (a)), (j = f [1]) {halinde (9 === ise!. k) {if (h = b.getElementById (j),! h ||! h.parentNode) d döndürür, eğer (h.id === j) d.push (h) döndürürseniz, d} else eğer (b .ownerDocument && (h = b.ownerDocument.getElementById (j)) && t (b, h) && h.id === j) d.push (h), d} else {if (f [2]) 'ı döndürür. Uygula (d, b.getElementsByTagName (a)), d; if ((j = f [3]) && c.getElementsByClassName && b.getElementsByClassName), I.apply (d, b.getElementsByClassName (j)), d} if (c, .qsa && (! k ||! q.test (a))) {halinde (s = r = u, w = B, x = 9 === k && a, 1 === k && "nesne"! ==, b. nodeName.toLowerCase ()) {o- = gr (a), (r = b.getAttribute ( "kimlik"))? s = r.replace (bb, "\\ $ &"): b.setAttribute (" id ", s), s =" [id = '"+ s +"'] ", l = o.uzunluk; iken (l -) o [l] = s + qb ( o [l]); w = ab.test (a) && ob (b.parentNode) || b, x = o.join (",")}, (x) {return I.apply (d, w. querySelectorAll (x)), d} catch (y) {} sonunda {r || b.removeAttribute ("id")}}} i döndürür (a.replace (R, "$ 1"), b, d, e) } fonksiyon gb () {var a = []; fonksiyon b (c, e) {return a.push (c + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e } return b} işlev hb (a) {return a [u] =! 0, a} işlevi ib (a) {var b = n.createElement ("div"); deneyin {return !! a (b)} yakala (c) {return! 1} sonunda {b.parentNode && b.parentNode.removeChild (b), b = null}} işlevi jb (a, b) {var c = a.split ("|"), e = a. uzunluk; süre (e -) d.attrHandle [c [e]] = b} işlev kb (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType &&(~ b.sourceIndex || D) - (~ a.sourceIndex || D); eğer (d) eğer d; eğer (c) iken (c = c.nextSibling) ise (c === b) return-1 ; dönüş a? 1: -1} işlevi lb (a) {return işlevi (b) {var c = b.nodeName.toLowerCase (); return "input" === c && b.type === a}} işlevi mb (a) {return işlevi (b) {var c = b.nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} işlevi nb (a) {return hb (fonksiyon (b) {dönüş b = + b, hb (fonksiyon (c, d) {varis, f = a ([], c. uzunluğu, b), g = f. uzunluğu ; iken (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})})} işlevi ob (a) { .getElementsByTagName! == C && a} c = fb.support = {}, f = fb.isXML = işlevi (a) {var b = a && (a.ownerDocument || a) .documentElement; return b? "HTML"! = = b.nodeName:! 1}, m = fb.setDocument = function (a) {var b, e = a? a.ownerDocument || a: v, g = e.defaultView; return e! == n && 9 == = e.nodeType && e.documentElement? (n = e, o = e.documentElement, p =! f (e), g && g! == g.top && (g.addEventListener? g.addEventListener ( "boşaltma", fonksiyon () {m ()}, ! 1): g.attachEvent && g.attachEvent ("onunload", function () {m ()})), c.attributes = ib (function (a) {return a.className = "i",! A.getAttribute ( "className")}), c.getElementsByTagName = ib (function (a) {return a.appendChild (e.createComment ("")) ,! a.getElementsByTagName ("*"). length}), c.getElementsByClassName ("*"). $ .test (e.getElementsByClassName) && ib (function (a) {return a.innerHTML = "<div class = 'a'> </div> <div class = 'a i'> </div>", a. firstChild.className = "i", 2 === a.getElementsByClassName ("i"). uzunluk}), c.getById = ib (işlev (a) {return o.appendChild (a) .id = u,! e .getElementsByName ||! e.getElementsByName (u) .length}), c.getById? (d.find.ID = function (a, b) {if (typeof b.getElementById! == C && p) {var c = b.getElementById! == C && p) {var c = b.getElementById (a); return c && c.parentNode? [c]: []}}, d.filter.ID = function (a) {var b = a.replace (cb, db); return işlevi (a) {return a.getAttribute ("id" ) === b}}) :( d.find.ID, d.filter.ID = silin (a) {var b = a.replace (cb, db); return işlevi (a) {var c = typeof a.getAttributeNode! == C && a.getAttributeNode ("id"); c && c.value === b}} döndürün, d.find.TAG = c.getElementsByTagName? function (a, b) {return typeof b.getElementsByTagName? function! == C? B.getElementsByTagName (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); eğer ("*" == = a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {return typeof b.getElementsByClassName! == C && p? b.getElementsByClassName (a): void 0}, r = [], q = [], (c.qsa = $. test (e.querySelectorAll)) && (ib (function (a) {a.innerHTML = "<select msallowclip = ''> <option selected = ''> </option> </select>", a.querySelectorAll ("[msallowclip ^ = '']"). uzunluk && q.push ("[* ^ $] = "+ M +" * (?: '| \ "\") "), a.querySelectorAll (" [seçilen] ") uzunluğu || q.push (." \\ [ "+ M +" * (?: değer | "+ L +") "), a.querySelectorAll (": checked "). uzunluk || q.push (": checked ")}), ib (fonksiyon (a) {var b = e.createElement (" giriş "); b.setAttribute (" türü", ""), a.appendChild (b) '.setAttribute ( "gizli ismi", "D"), a.querySelectorAll ( "[ad =-d]") uzunluğu && q.. itme ( "name" + M + "*? [* ^ $ |! ~] ="),a.querySelectorAll ( ": etkin"). uzunluk || q.push ", *:", a.querySelectorAll ( "* ,: x") q.push ((: "özürlü", "etkin") )})), (c.matchesSelector = $. testi (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ib (fonksiyon, (a) {c. disconnectedMatch = s.call (a, "div"), s.call (a, "[s = ''!]: x") ( "! =", s), r.push}), q = q. uzunluk ve & yeni RegExp (q.join ("|")), r = r.length && yeni RegExp (r.join ("|")), b = $. test (o.compareDocumentPosition), t = b || $ .test ( o.contains)? işlevi (a, b) {var c = 9 === a.nodeType? a.documentElement: a, d = b && b.parentNode; dönüş a === d ||! (! d || 1 ! == d.nodeType || (c.contains c.contains (d): a.compareDocumentPosition && 16 ve a.compareDocumentPosition (d))!)}: fonksiyonu (a, b) {(b) ise (b = b.parentNode) eğer (b === a)!! döndür; 0; dönüş! 1}, B = b? fonksiyonu (a, b) {if (a === b) döndürür l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition, (a) === d değeri bir === e || a.ownerDocument === v && t (v) -, 1:? b === e || b.ownerDocument === v && t (v, b) 1: k K.call (k, a) -K.call (k, b): 0: 4-Ge -1: 1)}: fonksiyonu (a, b) {ise (a = == b) l =! 0,0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], i = [b], eğer (! f ||! g) a === e? -1: b === e? 1: f? -1: g? 1: k? K.call (k, a) -K.call (k, b): 0 döndür ; (f === g), kb (a, b); c = a; while (c = c.parentNode) h.unshift (c); c = b; while (c = c.parentNode) i. vites değiştirme (c); süre (h [d] === i [d]) d ++; d? kb (h [d], i [d]) döndürür: h [d] === v -1 -1: i [d] === v? 1: 0}, e): n}, fb.matches = function (a, b) {return fb (a, null, null, b)}, fb.matchesSelector = function (a b) {((eğer a.ownerDocument || a)! == N && m (a), b = b.replace (U "= '$ 1']"),! (! c.matchesSelector || p! || r && r.test (b) '|| q && q.test (b))) deneyin {var d = s.call (a, b); eğer (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) d} catch döndürün (e) ) {} dönüş fb (b, n, null, [a]). uzunluk> 0}, fb.contains = function (a, b) {return (a.ownerDocument || a)! == n & m (a), t (a, b)}, fb.attr = işlevi (a, b) {(a.ownerDocument || a)! == n && m (a); var e = d.attrHandle [b.toLowerCase ()], f = e && E. call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; return void 0! == f? f: c.attributes ||! p? a.getAttribute (b) :( f = a.getAttributeNode (b)) && f.specified? f.value: null}, fb.error = function (a) {yeni hata at ("Sözdizimi hatası, tanınmayan ifade:" + a)} , fb.uniqueSort = işlevi (a) {var b, d = [], e = 0, f = 0; eğer (l =! c.detectDuplicates, k =! c.sortStable && a.slice (0), a.Sıralama (B), i) {ise (b = a [f ++]) b'yi === bir [f] && (e = d.push (f)), süre (E -) a.splice (d [e ], 1)} return k = null, a}, e = fb.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {if (1) === f || 9 === f || 11 === f) {if ("string" == typ.a.textContent), a.textContent; 'e (a = a.firstChild; a; a = a) .nextSibling) c + = e (a)} else (3 === f || 4 === f) a.nodeValue} else verirken (b = a [d ++]) c + = e (b); } d = fb.selectors = {cacheLength: 50, createPseudo: hB, maç: X attrHandle: {}, bulmak:} {nispi: { ">": {dir: "parentNode", ilk: 0} , "": {dir: "parentNode"}, "+": {dir: "öncekiSibling", önce:! 0}, "~": {dir: "öncekiSibling"}}, preFilter: {ATTR: function (a ) {[1] = a [1] döndürün. (cb, db), bir [3] = (bir [3] || a [4] || a [5] || "") yerine. cb, db), "~ =" === a [2] && (a [3] = "" + a [3] + ""),a.slice (0,4)}, CHILD: function (a) {[a] döndürür [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? (a [3] || fb.error (a [0]), bir [4] = + (a [4] [5] + (a [6] || 1): 2 (* "çift" === bir [3] || "tek" === bir [3])), a [5] = + (a [7] bir [8] || "tek" === bir [3] )): a [3] && fb.error (a [0]), a}, PSEUDO: function (a) {var b, c =! a [6] && a [2]; return X.CHILD.test (a [0]) boş:! && (b = gr (c, 0): (? c && V.test (c [3] [2] [4] [5] || "" || =) ) && (b = c.indexOf ( ""), c.length-b) '-c.length) && (a [0] = a [0] .slice (0, b) bir [2] = c. dilim (0, b)), a.slice (0,3))}}, filtre: {TAG: işlevi (a) {var b = a.replace (cb, db) .toLowerCase (); return "*" === a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, SINIF: işlev (a) {var b = y [a + " "]; b || (b = yeni RegExp (" (^ | "+ M +") "+ a +" ("+ M +"| $) ")) && y (a, function (a) {return b.test (" string "== typeof a.className && a.className || typeof a.getAttribute! == C && a.getAttribute (" class ") || "")})}, ATTR: işlevi (a, b, c) {return işlevi (d) {var e = fb.attr (d, a); return null == e? "! =" === b : B (e + = "", "=" === b, e === c: "=" === b, e == c:! "!? ^ =" === b c && 0 == ? = e.indexOf (c): "* =" === b c && e.indexOf (c)> - 1: "$ =" === b c && e.slice (-c.length) === c: "~ =" === b? ("" + e + "") .indexOf (c)> - 1: "| =" === b? e === c || e.slice (0, c. uzunluk + 1) === c + "-" :! 1) :! 0}}, ÇOCUK: işlevi (a, b, c, d, e) {var f = "nth"! == a.slice (0 , 3), g = "last"! == a.slice (-4), h = "türünden" === b; return 1 === d && 0 === e? İşlevi (a) {return! ! a.parentNode}: function (b, c, i) {var j, k,l, m, n, o, p = f == g "nextSibling":!?! "previousSibling", q = b.parentNode, R = H && b.nodeName.toLowerCase (), s = i h &&, eğer (q ) {(f) {(p) {l = b: süre (l = l [p]) (h l.nodeName.toLowerCase (eğer?) === r: 1 === l.nodeType) dönüş ! 1; o = p = "sadece" === bir && o && "nextSibling"} 0} ise iade! (o = [g q.firstChild: q.lastChild], g && ler) {k = q [u] | | (q, [u] = {}), j = k [a] || [], n = j [0] === ağırlık && j [1] m = j [0] === ağırlık && j [2], l = n && [n] q.childNodes; iken (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) halinde (1 === l.nodeType && ++ m && l == = b) {k [a] = [w, n, m]; break}} else eğer (s && (j = (b [u] || (b [u] = {})) [a]) && j [ 0] === w) m = j [1]; aksi halde (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) ise ((h? L.nodeName) .toLowerCase () === r: 1 === l.nodeType) && ++ m && (s && ((l [u] || (l [u] = {})) [a] = [ağırlık, m] ), l === b)) break, return m- = e,m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: işlevi (a, b) {var c, e = d.pseudos [a] || d.setFilters [a .toLowerCase ()] || fb.error ("desteklenmeyen sözde:" + a); e [u]? e (b): e.length> 1? (c = [a, a, "", b] değerini döndürün , d.setFilters.hasOwnProperty (a.toLowerCase ())? hb (fonksiyon (a, c) {var d, f = e (a, b), g = f. uzunluk; iken (g -) d = K .call (a, f [g]), a [d] =! (c [d] = f [g])}): işlevi (a) {return e (a, 0, c)}): e} }, pseudos: {not: hb (fonksiyon (a) {var b = [], c = [], d = h (a.replace (R, "$ 1")); d [u]? hb (fonksiyon (a, b, c, e) {var f, g = d (a, null, e, []), h = a. uzunluğu; iken (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): işlev (a, e, f) {return b [0] = a, d (b, null, f, c) ,! c.pop ( )}}), has: hb (fonksiyon (a) {dönüş fonksiyonu (b) {dönüş fb (a, b). uzunluk> 0}}), şunları içerir: hb (fonksiyon (a) {dönüş fonksiyonu (b) { return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: hb (işlev (a) {return W.test (a || "") | | fb.hata ("desteklenmeyen lang:" + a), a = a.replace (cb, db) .toLowerCase (), işlevi (b) {var c; eğer (c = p? b.lang: b.getAttribute (" xml: lang ") || b.getAttribute (" lang ")) döndürür c = c.toLowerCase (), c === a || 0 === c.indexOf (a +" - "); iken ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: işlevi (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b .id}, root: function (a) {return a === o}, focus: function (a) {return a === n.activeElement && (! n.hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, etkin: function (a) {return a.disabled ===! 1}, devre dışı: function (a) {return a.disabled === ! 0}, kontrol edildi: function (a) {var b = a.nodeName.toLowerCase (); "giriş" === b && !! a.checked || "option" === b && !! a.selected} değerini döndürün} , selected: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected === 0}, boş:! olan (a) {(a = a.firstChild a a = a.nextSibling) halinde (a.nodeType <6) 1, geri 0 }, parent: function (a) {return! d.pseudos.empty (a)}, header: function (a) {return Z.test (a.nodeName)}, input: function (a) {return Y.test (a.nodeName)}, button: function (a) {var b = a.nodeName.toLowerCase (); "input" === b && "button" === a.type || "button" === b}, text: function (a) {var b; "input" === a.nodeName.toLowerCase () && "text" döndürün === a.type && (null == (b = a.getAttribute ("type ")) ||" metin "=== b.toLowerCase ())}: birincisi, nb (fonksiyonu () {dönüş [0]}), son: nb (fonksiyonu (a, b) {geri [b-1 ]}), eq: nb (işlev (a, b, c) {return [0> c? c + b: c]}), hatta: nb (işlev (a, b) {for (var c = 0; b> c; c + = 2) a.push (c); a}) döndür, tek: nb (işlev (a, b) {için (var c = 1; b> c; c + = 2) a.push ( c); a}) döndür, lt:nb (işlev (a, b, c) {((var d = 0> c? c + b: c; - d> = 0;) a.push (d); a} döndür), gt: nb ( işlevi (a, b, c) {((var d = 0> c> c + b: c; ++ d <b;) a.push (d); a})}}, d.pseudos.nth için = d.pseudos.eq; ({b: {0:! 0, onay kutusu:! 0, dosya:! 0, şifre:! 0, görüntü:! 0}) için d.pseudos [b] = lb (b); (b {{:: 0, sıfırla:! 0}) içinde) d.pseudos [b] = mb (b); işlevi pb () {} pb.prototype = d.filters = d.pseudos, d.setFilters = yeni pb, g = fb.tokenize = işlev (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; .slice (0); h = a, i = [], j = d.preFilter; iken (h) {(c! || (e = S.exec (h))) && (e && (h = saat. dilim (e [0] .length) || h) i.push (f = [])), c =! 1, (e = T.exec (h)) && (c = e.shift (), f.push ({değer: c, şunu yazın: e [0]. yerine (R, "")}), h = h.slice (c.length)); için (d.filter'de g)! (e = ! x [g] .exec (h)) || j [g] && (e = j [g] (e)) || (c = e.shift (), f.push ({değeri: c, tip : g, eşleşmeler: e}), h = h.slice (c.length)); eğer (! c) break} döndürürse b? h.uzunluk: h? fb.error (a): z (a, i) .slice (0)}; işlev qb (a) {için (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .value; dönüş d} fonksiyonu rb (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = x ++; .first? işlevi (b, c, f) {while (b = b [d]) eğer (1 === b.nodeType || e) a (b, c, f)} döndürürse: function (b, c , g) {var h, i, j = [w, f]; eğer (g) {while (b = b [d]) ise ((1 === b.nodeType || e) && a (b, c , g))! 0} ifadesini döndürürken (b = b [d]) eğer (1 === b.nodeType || e) {if (i = b [u] || (b [u] = {} ), (h = i [d]) && h [0] === w && h [1] === f) döndürür j [2] = h [2]; eğer (i [d] = j, j [2] = a (b, c, g)) return! 0}}} function sb (a) {return a.length> 1? function (b, c, d) {var e = a.length; ) eğer (! a [e] (b, c, d))!! 1 döndür; geri! 0}: a [0]} işlevi tb (a, b, c) {için (var d = 0, e = b uzunluk; e> d; d ++) fb (a, b [d], c); dönüş c} işlevi ub (a, b, c, d, e) {için (var f, g = [], h = ! 0, i = a.length, j = boş b = i> h, h ++) (! f = a [h]) && (c || c (f, d, e)) && (örn.push (f), j && b.push (h)); dönüş g} işlevi vb (a, b, c, d, e, f) {dönüş d &&! d [u] && (d = vb (d)), e && ! e [u] && (e = vb (e, f)), hb (fonksiyon (f, g, h, i) {var j, k, l, m = [], n = [], o = g .length, p = f || tb (b || "*", h.nodeType [h]:? H, [])!?, q = bir || f && B p: ub (s, m, a, ? h, i) r = c e || (f a: o || d) [] .g:? q; (c && c (q, r, h, i), d) {j = ub ( r, n), d (j, [], h, i), k = j.length;! ise (k -) (l = j [k]) && (r [N- [k]] = (q })) = l [n [] k] (f) {durumunda (e || a) {(e) eğer {j = [], k = r.length; iken (k -) (l = r [k]) && j.push (q [k] = l), e (null, r = [], j, i)} k = r.length; iken (k -) (l = r [k]) && (j = e? K.call (f, l): m [k])> - 1 && (f [j] =! (g [j] = l))}} else r = ub (r === g? r.splice (o, r.length): r), e? e (null, g, r, i): I.apply (g, r)})} işlevi wb (a) {için (var b , c, e, f = uzunluk, g = d. göreli [a [0]. tipi], h = g || d. göreli [""], i = g? 1: 0, k = rb ( işlev (a) {return a === b}, h,! 0), l = rb (işlev (a) {return K.call (b, a)>-1} h! 0) m = [fonksiyonu (a, c, d) {geri! G && (d || c! == j) || ((b = c) .nodeType? K: (a, c, d): l (b, c, d))}] f> i; i ++) (c = d.relative [a [i] .Tip]) m = [rb (sb (m), c )]; başka {(c = d.filter [a [i] .Tip] .apply (boş bir [ı] .matches), c [u]) {(e = ++ i f> e ; e ++) eğer (d.relative [a [e] .type]) koparsa; vb (i> 1 && sb (m), i> 1 && qb (a.slice (0, i-1) .concat ({value: ") ":". * "? bir [i-2] .Tip ===") "})) (R yerine," $ 1" ), c, e> ı WB && (a.slice (i, e) f> e && wb (a = a.slice (e)), f> e && qb (a))} m.push (c)} return sb (m)} işlevi xb (a, b) {var c = b.length> 0, e = a.length> 0, f = işlevi (f, g, h, i, k) {var l, m, o, p = 0, q = "0", r = f && [], s = [] t || e && d.find.TAG ( "*", k) f j, u = = v w = + = null == t, 1: Math.random () || .1 x = u.length; için (! k && (j = gr == n && g);! q == x && boş = (l = u [q]) q ++) {halinde (e && l) {m = 0;ise ([++ m] bir = O) (O (l, l g, h)) {i.push (l) den ara} ise! k && (= h)} C && ((l = O && l) && p -, f && r .push (l))} halinde (p + = q c && q == p) {m = 0;! ise (= o b [m ++] o) (r, s, g, h) (f) {halinde (p> 0) ise (q -) r [k] || kullanıcının [q] || (s [k] = G.call (i)); s = uB (s)} I.apply (i, s), k &&! f && s.enlik> 0 && p + b.length> 1 && fb.uniqueSort (i)} dönüş k && (w = v, j = t), r}; dönüş c? hb (f): f} dönüş h = fb.compile = fonksiyon (a, b) {var c, d = [], e = [], f = A [a + ""]; eğer (! f) {b || (b = g (a)) , c = b.length; ise (c -) Rf = YT (b [c]), f [u] d.push (f): e.push (f) 'Rf = A (a, xb ( e, d)), f.selector = a} dönüş f}, i = fb.select = işlev (a, b, e, f) {var i, j, k, l, m, n = "işlev" = = bir && a, o =! f && g (a = n.selector || a) yazın; eğer (e = e || [], 1 === o.length) {if (j = o [0] = o [0 ] .slice (0), j.length> 2 && "İD" === (k = j [0]). === b.nodeType c.getById && 9 && tip &&p && d.relative [j [1] .Tip]) {(b = (d.find.ID (k.matches [0] .Kapağı (cb, db), b) || []) [0] ,! b) e; n && (b = b.parentNode), a = a.slice (j.shift (). value.length)} i = X.needsContext.test (a)? 0: j.length; i -) {halinde (k = j [i] d.relative [l = k.type]) kırmak; ((m = d.find [i] ise) && (= k e (k.matches [0 ] .Kapağı (cb, db), ab.test (j [0] .Tip) && ob (b.parentNode) || b))) {halinde (j.splice (i, 1), a = f.length && QB ( j) ,! a) return I. yerine (e, f), e; break}}} return (n || h (a, o)) (f, b,! p, e, ab.test (a) && ob (b.parentNode) || b), e}, c.sortStable = u.split ( ""). sıralama (B) .join ( "") === u c.detectDuplicates = !! l, m (), c.sortDetached = ib (işlev (a) {return 1 & a.compareDocumentPosition (n.createElement ("div"))}}), ib (işlev (a) {return a.innerHTML = "<a href = '# '> </a> " "#" === a.firstChild.getAttribute ( "href")}) || jb ("type | href | height | width ", function (a, b, c) {return c? void 0: a.getAttribute (b," type "=== b.toLowerCase ()? 1: 2)}), c .attributes && ib (fonksiyon (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("değer", ""), "" === a.firstChild.getAttribute ("değer")} ) || jb ("değer", işlev (a, b, c) {return c || "input"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), ib (işlev (a) ) {return null == a.getAttribute ("disabled")}) || jb (L, işlevi (a, b, c) {var d; dönüş c? void 0: a [b] ===! 0? b.toLowerCase () :(, d = a.getAttributeNode (b)) && d.specified d.value: null}), fb} (a) 'm.find = s, m.expr = s.selectors, m?. expr [":"] = m.expr.pseudos, m.unique = s.uniqueSort, m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains; var t = m. expr.match.needsContext u = / ^ <(\ w +) \ s * \ /?> (<?\ / \ 1> |) $ /, v = / ^. [^: # \ [\.,] * $ /; İşlev w (a, b, c) {eğer (m.isFunction (b)) m döndürür .grep (a, function (a, d) {return !! b.call (a, d, a)! == c}); eğer (b.nodeType) m.grep (a, function (a) { a === b! == c}); eğer ("string" == b) yazın eğer {eğer (v.test (b)) m.filter (b, a, c) döndürün; b = m.filter (b, a)} return m.grep (a, function (a) {return m.inArray (a, b)> = 0! == c})} m.filter = function (a, b, c) { var d = b [0]; c && (a = ": değil (" + a + ")"), 1 === b.length && 1 === d.nodeType? m.find.matchesSelector (d, a)? [d]: []: m.find.matches (a, m.grep (b, fonksiyon (a) {return 1 === a.nodeType}))}, m.fn.extend ({find: function ( a) {var b, c = [], d = bu, e = d.length; if ("string"! = a), this.pushStack (m (a) .filter (function () {için (b) = 0; e> b; L! taşırsa ++), (m.contains (d [b], bu)) geri 0})), (b = 0; e> b, b ++) m.find (a, d [ b], c); c = this.pushStack (e> 1? m.unique (c): c), c.selector = this.selector? this.selector + "" + a: a, c}, filter: function (a) {return this.pushStack (w (this, a || [] ,! 1))}, değil: function (a) { this.pushStack işlevini döndür (w (bu, a || [] ,! 0))}, is: function (a) {return !! w (bu, "string" == bir && t.test (a)? m ( a): a || [] ,! 1) .length}}); var x, y = a.document, z = / ^ (?: \ s * (<[\ \ \ W] +>) [^ >] * | # ([\ w -] *)) $ /, A = m.fn.init = function (a, b) {var c, d; if (! a) bunu döndürür; if ("string" == typeof a) {if (c = "<" === a.charAt (0) && ">" === a.charAt (a.length-1) && a.length> = 3? [null, a null]: z.exec (a) ',! c || c [1] && b) geri b || b.jquery (b || x) .find (a):? this.constructor, (b). bulun (a); if (c [1]) {if (b = b m? b [0] 'ın aynısını gösterir: b, m.merge (bu, m.parseHTML (c [1], b && b.nodeType? b.ownerDocument) || b: y,! 0)), u.test (c [1]) && m.isPlainObject (b)) için (b in b) m.isFunction (this [c])? bu [c] (b [ -c]): this.attr (c, B [c]);bunu döndürün} if (d = y.getElementById (c [2]), d && d.parentNode) {if (d.id! == c [2]) x.find (a) döndürün; this.length = 1, this [0] = d} this.context = y döndür, this.selector = a, this} return a.nodeType? (This.context = this [0] = a, this.length = 1, this): m.isFunction (a)? "undefined"! = typ.x.ready? x.ready (a): a (m) :( void 0! == a.selector && (this.selector = a.selector, this.context = a. bağlam), m.makeArray (a, this))}} A.prototype = m.fn, x = m (y); var B = / ^ (?: parent | prev (?: Tümüne kadar)) /, C = {children:! 0, içerikler:! 0, sonraki:! 0, prev:! 0}; m.extend ({dir: function (a, b, c) {var d = [], e = a [ b]; while (e && 9! == e.nodeType && (void 0 === c || 1! == e.nodeType ||! m (e) .is (c))) 1 === e.nodeType && d. push (e), e = e [b]; return d}, kardeş: function (a, b) {için (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! = = b && c.push (a); return c}}), m.fn.extend ({has: function (a) {var b, c = m (a, bu), d = c.length;this.filter (function () {((b = 0; d> b; b ++ b ++) için eğer (m.contains (this, c [b])) döndür! 0})}, en yakın: function (a, b) {(var c, d = 0, e = this.length, f = [], g = t.test (a) || "string"! = a = m (a, b || this.context) !: 0, e> D; (c d ++) = bu [d]; c && c == b: c = c.parentNode) halinde (c.nodeType <11 && (g g.index (c) -> 1: 1 === c.nodeType && m.find.matchesSelector (c, a))) {f.push (c); break}, this.pushStack işlevini döndürün (f.length> 1? M.unique (f): f)}, index: function (a) {bir a "dizgesi" == yazıp bir m.inArray yazın (bu [0], m (a)): m.inArray (a.jquery? a [0]: a, bu) : this [0] && this [0] .parentNode? this.first (). prevAll (). uzunluk: -1}, add: function (a, b) {return this.pushStack (m.unique (m.merge ( this.get (), m (a, b))))}, addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}) ; işlev D (a, b) {do a = a [b]; while (a & 1! == a.nodeType); a} m döndür.her ({parent: function (a) {var b = a.parentNode; return b && 11! == b.nodeType? b: null}, parent: function (a) {return m.dir (a, "parentNode")} , parentsUntil: function (a, b, c) {return m.dir (a, "parentNode", c)}, sonraki: function (a) {return D (a, "nextSibling")}, prev: function (a ) {return D (a, "öncekiSibling")}, nextAll: function (a) {return m.dir (a, "nextSibling")}, prevAll: function (a) {return m.dir (a, "priorSibling" )}, nextUntil: function (a, b, c) {return m.dir (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return m.dir (a, "priorSibling" , c)}, kardeşler: function (a) {return m.sibling ((a.parentNode || {}). firstChild, a)}, children: function (a) {return m.sibling (a.firstChild)} , content: function (a) {return m.nodeName (a, "iframe")? a.contentDocument || a.contentWindow.document: m.merge ([], a.childNodes)}},function (a, b) {m.fn [a] = işlev (c, d) {var e = m.map (this, b, c); "Dönene Kadar Dön"! == a.slice (-5) && (d = c), d && "string" == d && (e = m.filter (d, e)), this.length> 1 && (C [a] || (e = m.unique (e)), B.test (a) && (e = e.reverse ())), this.pushStack (e)}}); var E = / \ S + / g, F = {}; G (a) {var b = F [a] = {}; m.each (a.match (E) || [], işlevi (a, c) döndürün {b [c] =! 0}), b} m.Callbacks = function ( a) {a = "string" == a? F [a] || G (a): m.extend ({}, a); var b, c, d, e, f, g, h = [ ], i =! a.once && [], j = fonksiyonu (l) {(c = a.memory && l, D =! 0, = g || 0, c = 0 m, e = h.length, b = ! 0, h && e> f f ++), (h [f] .apply (I [0], l [1]) === 1 && a.stopOnFalse) {c = 1;! ara}! b = 1 saat && (i? ı.enjth && j (i.shift ()): c? h = []: k.disable ())}, k = {add: function () {if (h) {var d = h.length; ! function f (b) {m.each (b, işlev (b, c) {var d = m.type (c); "function" === d? a.Benzersiz && k.has (c) '|| h.push (c): c && c.length && "dizge" == d && f (c)})} (bağımsız), b, e = h.length:? c && (g = d, J (c))} bunu döndürün}, remove: function () {return h && m.each (argümanlar, function (a, c) {var d; while ((d = m.inArray (c, h, d))) - - 1) h.splice (d, 1), b && (e> = d && e -, f> = d && f -)}), bu}, var: function (a) {return a? M.inArray (a, h )> - 1:! (! H ||! H.length)}, empty: function () {return h = [], e = 0, this}, disable: function () {return h = i = c = void 0, this}, disabled: function () {return! h}, lock: function () {return i = void 0, c || k.disable (), this}, kilitli: function () {return! i } firewith: fonksiyonu (a, c) {geri h || d && ı || (= c, c || [], c = [a, c.slice c.slice (): c]! b? i.push (c): j (c)), bu}, fire: function () {return k.fireWith (this, bağımsız değişkenler), this}, ateşlendi: function () {return !! d}}; return k }, m.extend ({Ertelenmiş: işlev (a) {var b = [[""," yapıldı ", m.Callbacks (" bir kez bellek ")," çözüldü "], [" reddet "," başarısız ", m.Callbacks (" bir kez bellek ")," reddedildi "], [" bildir "i çöz , "progress", m.Callbacks ("memory")]], c = "pending", d = {state: function () {return c}, her zaman: function () {return e.done (arguments) .fail (argümanlar), bu}, o zaman: function () {var a = arguments; dönüş m.Deferred (function (c) {m.each (b, fonksiyon (b, f) {var g = m.isFunction (a [ b]) && a [b]; e [f [1]] (function () {var a = g && g.apply (this, argümanlar); a & m.isFunction (a.promise)? a.promise (). .resolve) .fail (c.reject) .adresine yapabilirsiniz (c.notify): c [f [0] + "ile"] Bu (=== d c.promise (?): Bu, g [a]: bağımsız değişkenler)})}), a = null}) promise ()}, promise: function (a) {return null! = a? m.extend (a, d): d}}, e = {}; d.pipe = d.then, m.each (b, fonksiyon (a,f) {var g = f [2], h = f [3]; d [f [1]] = g.add, h && g.add (function () {c = h}, b [1 ^ a] [ 2] .disable, b [2] [2] .lock), e [f [0]] = function () {return e [f [0] + "With"] (this === e? D: this , bağımsız değişkenler), bu} e [f [0] + "ile"] = g.fireWith}), d.promise (e) bir && a.call (e, e), e}, zaman: olan (a) {var b = 0, c = d.call (argümanlar), e = c.length, f = 1! == e || a & m.isFunction (a.promise)? e: 0, g = 1 === f a: m.Deferred (), h = fonksiyon (a, b, c) {return işlev (e) {b [a] = bu, c [a] = arguments.length> 1? d.call (bağımsız değişkenler) : e, c === i g.notifyWith (b, c): -? || g.resolveWith (b, c)}} i, j, k, m, eğer (e> 1) için (i = yeni Dizi (e), j = yeni Dizi (e), k = yeni Dizi (e); e> b; b ++) c [b] && m.isFunction (c [b] .promise)? c [b] .promise () .done (h (b, k, c)). başarısız (g.reject) .progress (h (b, j, i)): - f; dönüş f || g.resolveWith (k, c) , g.promise ()}}); var H; m.fn.ready = function (a) {return m.ready.promise (). done (a), bu}, m.extend ({isReady:! 1 , readyWait:1, holdReady: function (a) {a m.readyWait ++: m.ready? (0!)}, Hazır: function (a) {if (a === 0 - m.readyWait:!?!! M. isReady) {if (! y.body), setTimeout (m.ready) döndürür; m.isReady =! 0, a! ==! 0 && - m.readyWait> 0 || (H.resolveWith (y, [m] ), m.fn.triggerHandler && (m (y) .triggerHandler ("hazır"), m (y) .off ("hazır")))}}}; işlev I () {y.addEventListener? (y. removeEventListener ( "DOMContentLoaded", J! 1), a.removeEventListener ( "yük", J! 1)) :( y.detachEvent ( "onreadystatechange", J) a.detachEvent ( "onload", J.)) } işlev J () {(y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I (), m.ready ())} m.ready. söz = işlev (b) {eğer (! H) ise (H = m.Deferred (), "tamamlandı" === y.readyState) setTimeout (m.ready); else eğer (y.addEventListener) y.addEventListener ( "DOMContentLoaded", J,! 1), a.addEventListener ("load", J,! 1); else {y.attachEvent ("onreadystatechange", J), a.attachEvent ("onload", J); var c =! 1; try {c = null == a .frameElement && y.documentElement} catch (d) {} ​​c && c.doScroll &&! işlevi e () {if (! m.isReady) {try {c.doScroll ("left")} catch (a) {return setTimeout (e, 50 )} I (), m.ready ()}} ()} return H.promise (b)}; var K = "undefined", L; (L (m (k))) sonu; k.ownLast = " 0 "! == L, k.inlineBlockNeedsLayout =! 1, m (function () {var a, b, c, d; c = y.getElementsByTagName (" body ") [0], c && c.style && (b = y .createElement ( "div"), d = y.createElement ( "div"), d.style.cssText = "konumu: mutlak; sınır: 0; genişliği: 0; yükseklik: 0; en: 0, sol: -9999px ", c.appendChild (d) .appendChild (b), b.style.zoom yazınız! == K && (b.style.cssText =" display: inline; marj: 0; border: 0;dolgu: 1 piksel; genişliği: 1 piksel; zum: 1" , k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, bir && (c.style.zoom = 1)), c.removeChild (d))}), fonksiyon () {var a = y.createElement ("div"); eğer (null == k.deleteExpando) {k.deleteExpando =! 0; deneyin {delete a.test} yakala (b) {k.deleteExpando =! 1 }} a = null} (), m.acceptData = function (a) {var b = m.noData [(a.nodeName + "") .toLowerCase ()], c = + a.nodeType || 1; return 1 ! == c && 9! == c?! 1:! b || b! ==! 0 && a.getAttribute ("classid") === b}; var M = / ^ (?: \ {[\ w \ W ] * \} | \ [[\ w \ W] * \]) $ /, N = / ([AZ]) / g; işlevi O (a, b, c) {eğer (geçersiz 0 === c && 1 = == a.nodeType) {var d = "veri -" + b.replace (N, "- $ 1"). toLowerCase (); if (c = a.getAttribute (d), "string" == ct) {{c = "true" === c denemek 0:?! "false" === c 1:?! "boş" === c null adlı: + c + "" === c + c:? M .test (c) m.parseJSON (c): a} yakalamak (e) {} m.data (a, b,c)} else c = void 0} c} fonksiyonunu döndürür P (a) {var b; (a) b için (("data"! == b ||! m.isEmptyObject (a [b])) && "toJSON"! == b) return! 1; return! 0} işlevi Q (a, b, d, e) {if (m.acceptData (a)) {var f, g, h = m.expando, i = a.nodeType, j = i m.cache: a, k = i [h]:? bir [h] && saat;
if (k && j [k] && (e || j [k] .data) || void 0! == d || "string"! = b = typeof b) geri dönün k || (k = i? a [h] = c.pop () || m.guid ++: h), j [k] || (j [k] = i? {}: {toJSON: m.noop}), ("nesne" == typeof b || "function" == (b [typ] b) && (e? j [k] = m.uzanım (j [k], b): j [k] .data = m.uzan (j [k] .data, b)) , g = j [k], e || (g.data || (g.data = {}), g = g.data), geçersiz 0! == d && (g [m.camelCase (b)] = d), "string" == b = (f = g [b], null == f && (f = g [m.camelCase (b)])) =: f = g, f}} işlev R (a, b, c) {if (m.acceptData (a)) {var d, e, f = a.nodeType, g = f? m.cache: a, h = f? a [m.expando]: m.expando ; (g [h]) {(b && (D = c gr [h]: g [h] .Data))? {m.isArray (b) b = b.concat (m.map (b, m.camelCase)): db'de b = [b] :( b = m.camelCase (b), b = dd içinde [b]: b.split ("")), e = b. uzunluğu ; ((- -) d [b [e]] silmek; eğer (c?! P (d) :! m.isEmptyObject (d)) return} (c || (sil g [h] .data, P) (g [h]))) && (f m.cleanData ([a] ,! 0): k.deleteExpando || g! = g.window? delete g [h]: g [h] = null)}}} m.extend ({cache: {}, noData: {"applet":! 0, "embed": ! 0, "object": "clsid: D27CDB6E-AE6D-11cf-96B8-444553540000"}, hasData: function (a) {return a = a.nodeType? M.cache [a [m.expando]]: a [ m.expando], !! a &! P (a)}, data: function (a, b, c) {return Q (a, b, c)}, removeData: function (a, b) {return R (a , b)}, _ data: function (a, b, c) {return Q (a, b, c,! 0)}, _ removeData: function (a, b) {return R (a, b,! 0)} }), m.fn.extend ({data: function (a, b) {var c, d, e, f = bu [0], g = f && f. öznitelikleri; eğer (void 0 === a) {eğer (this.length && (e = m.data (f) 1 === f.nodeType && m._data (f, "parsedAttrs"))) {c = g.length; ise (c -) g- [c ] && (d = l g [c] .name, 0 === d.indexOf ( "verileri -") && (d = m.camelCase (d.slice (5)), O (f, d, e [d ]))); m._data (f, "parsedAttrs",! 0)} return e} return "object"== typeof a? this.each (function () {m.data (this, a)}): arguments.length> 1? this.each (function () {m.data (bu, a, b)}) : f? O (f, a, m.data (f, a)): void 0}, removeData: function (a) {return this.each (function () {m.removeData (this, a)})} }), m.extend ({kuyruk: işlev (a, b, c) {var d; bir a döndürür (b = (b || "fx") + "sıra", d = m._data (a, b ), c && (! d || m.isArray (c)? d = m._data (a, b, m.makeArray (c)): d.push (c)), d || []): geçersiz 0 }, dequeue: function (a, b) {b = b || "fx"; var c = m.queue (a, b), d = c.length, e = c.shift (), f = m. _queueHooks (a, b), c = fonksiyonu () {m.dequeue (a, b)}; "InProgress" === e && (e = c.shift (), d -) e && ( "fx" = == b && c.unshift ("devam ediyor"), f.stop öğesini silin, e.call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; dönüş m._data (a, c) || ​​m._data (a, c, {boş: m.Callbacks ("bir kez bellek "). add (function () {m._removeData (a, b +" sıra "), m._removeData (a, c)})})}}), m.fn.extend ({queue: function ( a, b) {var c = 2; "string"! = döndürün, bir && (b = a, a = "fx", c -), arguments.length <c? m.queue (this [0], a ): void 0 === b? this: this.each (function () {var c = m.queue (this, a, b); m._queueHooks (this, a), "fx" === a && " inprogress "! == c [0] && m.dequeue (this, a)})}, dequeue: function (a) {return this.each (function () {m.dequeue (this, a)})}, clearQueue : function (a) {return this.queue (a || "fx", [])}, söz ver: function (a, b) {var c, d = 1, e = m.Deferred (), f = this , g = this.length, h = function () {- d || e.resolveWith (f, [f])}; "string"! = bir && (b = a, a = boşluk 0), a = a || "fx"; iken (g -) c = m._data (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); dönüş h () e.söz (b)}}); var S = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. kaynak, T = ["Üst", "Sağ", "Alt", "Sol"], U = fonksiyon (a, b) {return a = b || a, "none" === m.css (a, "ekran" ) ||! m.contains (a.ownerDocument, a)}, V = m.access = function (a, b, c, d, e, f, g) {var h = 0, i = a. j = null == c; eğer ("object" === m.type (c)) {e =! 0; (c için h) için m.access (a, b, h, c [h] ,! 0, f, g)} else eğer (void 0! == d && (e =! 0, m.isFunction (d) || (g =! 0), j && (g? (B.call (a, d) , b = null) :( j = b, b = işlevi (a, b, c) {dönüş j.call (m (a), c)})), b)) (; i> h; h ++) b (a [h], c, gd: d.call (a [h], h, b (a [h], c))); dönüş e aa: j b b.call (a): i? b (a [0], c): f}, W = / ^ (?: onay kutusu | radyo) $ / i;! function () {var a = y.createElement ("input"), b = y .createElement ("div"), c = y.createDocumentFragment (); if (b.innerHTML = "<link/><table> </table> <a href = '/ a'> a </a> <input type = 'checkbox' /> ", k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody =! b.getElementsByTagName (" tbody "). uzunluk, k.htmlSerialize . = !! b.getElementsByTagName ( "bağlantı") uzunluk, k.html5Clone = "<: nav> </: nav>"!. (! 0) == y.createElement ( "nav") cloneNode .outerHTML, bir .Type = "checkbox", a.checked =! 0, c.appendChild (a) k.appendChecked = a.checked, b.innerHTML = "<textarea> x </ textarea>", k.noCloneChecked = !! b.cloneNode (! 0) .lastChild.defaultValue, c.appendChild (b), b.innerHTML = "<giriş türü = 'radyo' kontrol edildi '' kontrol edildi '' = 't' />", k.checkClone = b .cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, k.noCloneEvent =! 0, b.attachEvent && (b.attachEvent ( "onclick", fonksiyon () {k.noCloneEvent =! 1}), b .cloneNode (! 0) .click ()),null == k.deleteExpando) {k.deleteExpando =! 0; {sil b.test} yakalamayı dene (d) {k.deleteExpando =! 1}}} (), function () {var b, c, d = y.createElement ("div"); (b {gönder:! 0, değişiklik:! 0, focusin:! 0}) için c = "on" + b üzerinde, (k [b + "Kabarcıklar"] = c ) || (d.setAttribute (c, "t"), k [b + "Kabarcıklar"] = d.atributes [c] .expando ===! 1); d = null} (); var X = / ^ (?: girdi | seçeneğini | textarea) $ / i, Y = / ^ anahtar / Z = / ^ (?: fare | işaretçi | contextmenu) | tıklayın /, $ = / ^ (?: focusinfocus | focusoutblur) $ / , _ = / ^ ([^.] *) (?: \. (. +) |) $ /; fonksiyon ab () {return! 0} işlev bb () {return! 1} işlev cb () {deneyin {return y.activeElement} catch (a) {}} m.event = {global: {}, add: function (a, b, c, d, e) {var f, g, h, i, j, k , i, n, o, p, q, r = m._data (a) 'da (r) {c.handler && (i = c, c = i.handler e = i.selector), c.guid | | (c.guid = m.guid ++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = fonksiyonu ( ) {m türünü döndür m === K || a && m.event.tetiklenen === a.type? void 0: m.event.dispatch.apply (k.elem, argümanlar)}, k.elem = a), b = (b || ""). match (E) || [ ""], s = b.length;. iken (h -) f = _ exec (b [h]) || [], = Q, = f o [1], s = (f [2] | "(..?") sıralama (), o && (j = m.event.special [o] || {} o = (e j.delegateType: j.bindType) | "). bölünmüş" || o j = m.event.special [o] || {}, I = m.extend ({türü: o origType: q, veriler: d, işleyici: c, rehberlik: c.guid, seçici: e, needsContext: e && m.expr.match.needsContext.test (e) ad: p.join ( "")}, i), (n = g [o]) || (n = g [o] = [], n .delegateCount = 0, j.setup && j.setup.call (a, d, s, k) == 1 || (a.addEventListener a.addEventListener (o, k, 1):!?! a.attachEvent && a.attachEvent (+ o "açık", k)))), j.add.call (a, l (&& j.add, l.handler.guid || (l.handler.guid = c.guid)) e? n .splice (n.delegateCount ++, 0, l): n.push (I), m.event.global [a] = 0); a = boş}} kaldırmak: fonksiyon (a, b, c, d, e) {var f, g, h,i, j, k, l, n, o, p, q, r = m.hasData (a) && m._data (a) 'da (r && (k = r.events)) {b = (b ||" = Q = H [o || [], -; ") .match (E) ||) (h = _ exec (b [j] ise (j [" "], j = b.length.) 1], s = (h [2] || ""). bölme ( ""). sıralama () o) {l = m.event.special [o] || {} o = (D? l.delegateType: l.bindType) || o, n = k [o] || [], h = h [2] && new RegExp ("(^ | \\.)" + p.join ("\\. .! (?:.. * \\ |) ") +" (\\ | $) "), i = f = n.length; (f iken -) g = n [f] ,! e && q == g.origType || c && c.guid! == g.guid || h &&! h.test (g.namespace) || d && d! == g.selector && ( "**"! == d ||! g.selector ) || (n.splice (f, 1), g.selector && n.delegateCount -, l.remove && l.remove.call (a, g)) i && n.length && (l.teardown && l.teardown.call (a! , p, r.handle)! ==! 1 || m.removeEvent (a, o, r.handle), k [o])} öğesini silin (k içinde o) m.event.remove (a, o + b [j], c, d, 0!);m.isEmptyObject (k) && (sil r.handle, m._removeData (a, "olaylar"))}}, tetikleyici: işlev (b, c, d, e) {var f, g, h, i, k , I, n, o = [d || y], s = j.call (b, "tip") b.type: B, Q = j.call (b, "ad") b.namespace?. bölme ( ""):!. [], (h = l = D = d || eğer y, 3 == d.nodeType && 8 == d.nodeType && $ testi (p + m.event.triggered) && (p.indexOf ()> = 0 && (q = p.split (), s = q.shift (), q.sort ()), g = p.indexOf ( " "". "":") < 0 && "on" + p, b = b [m.expando]? B: yeni m.Event (p, "nesne" == b && b tipi), b.isTrigger = e? 2: 3, b.namespace = q. join ("."), b.namespace_re = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. (?:. * \\. |)") + " (\\. | $) "): null, b.result = boşluk 0, b.target || (b.target = d), c = boş == c? [b]: m.makeArray (c, [ b]), k = m.event.special [p] || {} e ||! k.trigger || k.trigger.uygulanır (d, c)! ==! 1)) {halinde (! e &&! k.noBubble &&! m.isWindow (d)) {(i = k.delegateType || p $. testi (i p +) || (h = h.parentNode) h, h = h.parentNode) o.push (h) l = H; l === (d.ownerDocument || y) && o.push (l.defaultView || l.parentWindow || a)}, n = 0; iken ([n ++] (h = o) && b.isPropagationStopped ()) b.type = n> 1 i:!? k.bindType || p, f = ( m._data (s, "etkinlik") || {}) [b.type] && m._data (s, "kol"), f.apply f && (H, c) = gr && h [g] f && f.apply && m f .acceptData (h) && (b.result = f.apply (H, c), b.result === 1 && b.preventDefault ()!)! halinde (b.type p = e && b.isDefaultPrevented () && (! k._default || k._default.apply (o.pop () c) ===! 1) && m.acceptData (d) && g && d [p] &&! m.isWindow (d)) {l = d [g], l && (d [g] = null), m.event.triggered = p; deneyin {d [p] ()} catch (r) {} m.event.triggered = geçersiz 0, l &&(d [g] = l)} return b.result}}, gönderme: function (a) {a = m.event.fix (a); var b, c, e, f, g, h = [], i = d.call (bağımsız), j = (m._data (bu, "etkinlik") || {}) [a.type] || [] = m.event.special [a.type] k | | {} (i [0] = a, a.delegateTarget = Bu, k.preDispatch || k.preDispatch.call (bu, a) '== 1!!) halinde {h = m.event.handlers. çağrı (bu, bir j), b = 0; iken ((= f h [b ++]) && a.isPropagationStopped ()!) {a.currentTarget = f.elem, g = 0; iken ((e = f .handlers [g ++]) &&! a.isImmediatePropagationStopped ()) (! a.namespace_re || a.namespace_re.test (e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((m.event.special [e.origType] || {}). handle || e.handler) .apply (f.elem, i), void 0! == c && (a.result = c) == =! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, a), a.result}}, işleyiciler: function (a, b) {var c, d, e, f, g = [], s = b.delegateCount, i = a.target; (h &&i.nodeType && için) ((! a.button || == a.type "tıklama"); i = Bu;! i = i.parentNode bu ||) if (1 === i.nodeType && (i. engelli == 0 || "klik" == a.type)) {(e = [], f = 0;!! h> f f ++) d = b [f], c = d.selector +" ", geçersiz 0 === e [c] && (e [c] = d.needsContext? m (c, bu) .index (i)> = 0: m.find (c, bu, null, [i] ). uzunluk), e [c] && e.push (d); e.length && g.push ({elem: i, işleyicileri: e})} h <b.length && g.push ({elem: this, işleyicileri: b) .slice (h)}), g}, fix: function (a) {if (a [m.expando]) a döndürür; var b, c, d, e = a.type, f = a, g = this .fixHooks [e] g || (? this.fixHooks [e] = g = Z.test (e) this.mouseHooks: Y.test (e) this.keyHooks: {}), d = g.props a this.props.concat (g.props): this.props, a = yeni m.Event (f), b = d.hergth; iken (b -) c = d [b], a [c] = f [c]; a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey =! ! a.metaKey, g.filter? g.filter (a, f): a}, sahne: "altKey, canlandırılabilir ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey hedef timeStamp görünümünü hangi" .split (""), fixHooks: {}, keyHooks: { props: "char charCode key keyCode" .split (""), filter: function (a, b) {return null == a.which && (a.which = null! = b.charCode? b.charCode: b.keyCode) ), a}}, mouseHooks: {props: "buton düğmeleri clientX istemcisini Element ofsetX ofset ofset of pageX pageY screenX screenY toElement" .split (""), filter: function (a, b) {var c, d, e, f = b.button, g = b.fromElement; return null == a.pageX && null! = b.clientX && (d = a.target.ownerDocument || y, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (E && e.clientTop || c && c.clientTop || 0)) ,! a.relatedTarget && g && (a.relatedTarget = gr === a.target?b.toElement:g), a.which || void 0 === f || (a.which = 1 & f? 1: 2 & f? 3: 4 & f? 2: 0), a}}, özel: {load: {noBubble:! 0}, odak : {trigger: function () {if (this! == cb () && this.focus) deneyin {return this.focus () ,! 1} catch (a) {}}, delegateType: "focusin"}, bulanıklık: {trigger: function () {this this === cb () && this.blur? (this.blur () ,! 1): void 0}, delegateType: "focusout"}, tıklayın: {trigger: function () { return m.nodeName (bu, "input") && "checkbox" === this.type && this.click? (this.click () ,! 1): void 0}, _ default: function (a) {return m.nodeName (a.target, "a")}}, yüklemeden önce: {postDispatch: function (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}, simule et: işlev (a, b, c, d) {var e = m.extend (yeni m.Event, c, {type: a, isSimulated:! 0, originalEvent: { }}), d m.event.trigger (yani, boş, b): m.event.dispatch.call (b, e), e.isDefaultPrevented () && c.preventDefault ()}} m.removeEvent = y .removeEventListener? işlevi (a, b, c) {a.removeEventListener && a.removeEventListener (b, c,! 1)}: işlev (a, b, c) {var d = "on" + b; a [d] === K && (a [d] = null), a.detachEvent (d, c))}, m.Event = function (a, b) {bu bilgiyi döndürün m.Event? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1? ab: bb): this.type = a, b && m.eksaat (this, b), this.timeStamp = a && a.timeStamp || m.now (), void (this [m.expando] =! 0)): yeni m.Event (a, b)} , m.Event.prototype = {isDefaultPrevented: bb,isPropagationStopped: bb, isImmediatePropagationStopped: bb, engellemekDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = ab, a && (a.preventDefault? a.preventDefault (): a.returnVal = dur. function () {var a = this.originalEvent; this.isPropagationStopped = ab, a && (a.stopPropagation && a.stopPropagation (), a.cancelBubble =! 0)}, stopImmediatePropagation: function () {var a = this.originalEvent; .isImmediatePropagationStopped = ab bir && a.stopImmediatePropagation && a.stopImmediatePropagation (), this.stopPropagation ()}} m.each ({MouseEnter: "fare", mouseLeave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"} , function (a, b) {m.event.special [a] = {delegateType: b, bindType: b, işle: işlevi (a) {var c, d = bu, e = a.relatedTarget, f = a. handleObj;! dönüşü (e || e == d &&!m.contains (d, e)) && (a.type = f.origType, C = f.handler.apply (bu, bağımsız değişkenler), a.type = b), c}}}), k.submitBubbles || (m.event.special.submit = {setup: function () {return m.nodeName (bu, "form") ?! 1: void m.event.add (bu, "click._submit keypress._submit", işlev (a) {var b = a.target, c = m.nodeName (b, "input") || m.nodeName (b, "button")? b.form: void 0; c &&! m._data (c "submitBubbles") && (m.event.add (c, "submit._submit" olan (a) {a._submit_bubble =! 0}), m._data (c, "submitBubbles",! 0))} )}, postDispatch: function (a) {a._submit_bubble && (a._submit_bubble silin, this.parentNode &&! a.isTrigger && m.event.simulate ("gönder", this.parentNode, a,! 0))}, teardown: function () {return m.nodeName (bu, "form") ?! 1: void m.event.remove (bu, "._ Gönder")}}), k.changeBubbles || (m.event.special.change = {setup: function () {return X.test (this.nodeName)? ((("checkbox" === this.type || "radio" === bu). tipi) && (m.event.add (bu, "propertychange._change", function (a) {=== a.originalEvent.propertyName && "işaretli" (this._just_changed =! 0)}), m.event.add (Bu, "click._change" olan (a) {this._just_changed &&! a.isTrigger && (this._just_changed =! 1), m.event.simulate ( "değişim", bu bir,! 0)})) ,! 1): void m.event.add (bu, "beforeactivate._change", işlev (a) {var b = a.target; X.test (b.nodeName) &&! M._data (b, "changeBubbles ") && (m.event.add (b," change._change", function (a) {! this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate ( "değişim", bu .parentNode, bir,! 0)}), m._data (b, "changeBubbles",! 0))})},handle: function (a) {var b = a.target; bunu döndürün! == b || a.isSimulated || a.isTrigger || "radio"! == b.type && "checkbox"! == b.type ? a.handleObj.handler.apply (this, argümanlar): void 0}, teardown: function () {return m.event.remove (this, "._ change") ,! X.test (this.nodeName)}} ), k.focusinBubbles || m.each ({focus: "focusin", blur: "focusout"}, işlev (a, b) {var c = işlev (a) {m.event.simulate (b, a. target, m.event.fix (a) ,! 0)}; m.event.special [b] = {setup: function () {var d = this.ownerDocument || this, e = m._data (d, b); e || d.addEventListener (a, c,! 0), m._data (d, b, (e || 0) +1)}, teardown: function () {var d = this.ownerDocument | | Bu, e = m._data (d, b) 1;? e m._data (d, b, e) :( d.removeEventListener (! a, c, 0), m._removeData (d, b) )}}}), m.fn.extend ({on: function (a, b, c, d, e) {var f, g; if ("object" == typeof a) {"string"! = typeof b && (c = c || b, b = boşluk 0);(a'daki f) için this.on (f, b, c, a [f], e); bunu döndürün} eğer (null == c && null == d? (d = b, c = b = boşluk 0): null == d && ("string" == b tipi b? (d = c, c = boşluk 0) :( d = c, c = b, b = boşluk 0)), d ===! 1) d = bb ; aksi takdirde (! d) bunu döndürür; 1 === e && (g = d, d = işlev (a) {döndür m (). kapalı (a), g.apply (this, argümanlar)}, d. guid = g.guid || (g.guid = m.guid ++)), this.each (fonksiyonu () {m.event.add (bu, a, D, c, B)})}, bir: fonksiyonu ( a, b, c, d) {(this, on, a, b, c, d, 1)}, kapalı: işlev (a, b, c) {var d, e; eğer (a && a.preventDefault && a.handleObj) dönüş d = a.handleObj, m (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), bu; "== typeof a) {(a içindeki e) için this.off (e, b, a [e]); bunu döndürün} return (b ===! 1 ||" function "== typeof b) && ( c = b, b = geçersiz 0), c ===! 1 && (c = bb), this.each (function () {m.event.remove (bu, a, c, b)})},trigger: function (a, b) {return this.each (function () {m.event.trigger (a, b, bu)})}, triggerHandler: function (a, b) {var c = this [0] ; return c? m.event.trigger (a, b, c,! 0): void 0}}); işlev db (a) {var b = eb.split ("|"), c = a.createDocumentFragment ( ); if (c.createElement) iken (b.length) c.createElement (b.pop ()); return c} var eb = "abbr | article | aside | audio | bdi | canvas | data | datalist | details | figcaption | figure | footer | header | hgroup | mark | meter | nav | output | progress | section | özeti | zaman | video ", fb = / jQuery \ d + =" (?: null | \ d +) "/ g, gb = yeni RegExp ("<(?:" + eb + ") [\ s />]", "i"), hb = / ^ \ s + /, ib = / <(?! area | br | col | embed | saat | img | giriş | bağlantı | meta | param) (([\ w:] +) [^>] *) \ /> / gi, JB = / <([\ w:] +) / kb = ? / <tbody / i, lb = / <| & # \ w +; /, mb = / <(?: komut | tarzı | link) / i, nb = / \ s * checked (: [^ =] |? = \ * .checked s) / i, ob = / ^ $ |. \ / (?: java | ECMA) komut dosyası / i,(. *) Pb = / ^ true \ / /, qb = / ^ \ s * <! (: \ [| - CDATA \ [| (?: \] \?)] | -)> \ s * $ / g, rb = {seçenek: [1, "<çoklu seç = 'çoklu'>", "</select>"], açıklama: [1, "<fieldset>", "</fieldset>"], alan: [1, "<harita>", "</ harita>"], param: [1, "<object>", "</ object>"], thead: [1, "<tablo>"," </ table> "], t,: [2," <tablo> <tbody> " "</ tbody> </ table>"], sütun: [2," <tablo> <tbody> </ tbody> < COLGROUP>", "</ COLGROUP> </ table>"], td: [3, "<tablo> <tbody> <tr>", "</ tr> </ tbody> </ table>"] _ varsayılan : k.htmlSerialize [0 "", ""]: [1, "X" div>", "</ div>"]}, SB = db (y)tb = sb.appendChild (y.createElement ( "div")); rb.optgroup = rb.option, rb.tbody = rb.tfoot = rb.colgroup = rb.caption = rb.thead, rb.th = rb. td; fonksiyon ub (a, b) {var c, d, e = 0, f = a.getElementsByTagName! == K? a.getElementsByTagName (b || "*"): typeof a.querySelectorAll! == K ? a.querySelectorAll (b || "*"): void 0; (f = [] için c = a.childNodes || a; null! = (d = c [e]); e ++ )! b || m.nodeName (d, b)? f.push (d): m.merge (f, ub (d, b)); return void 0 === b || b && m.nodeName (a, b)? m.merge ([a], f): f} işlev vb (a) {W.test (a.type) && (a.defaultChecked = a.checked)} işlevi wb (a, b) {return m.nodeName (a, "tablo") && m.nodeName (! 11 == b.nodeType b: b.firstChild, "tr")? a.getElementsByTagName ( "tbody") [0] || a.appendChild ( a.ownerDocument.createElement ("tbody")): a} işlevi xb (a) {return a.type = (null! == m.find.attr (a, "type")) + "/"+a.type, a fdk işlevi yb (a) {var b = pb.exec (a.type); return b a a.type = b [1]: a.removeAttribute ("type"), a} zb (a, b) işlevi {((c, d = 0; var; null! = (c = a [d]); d ++) m._data (c, "globalEval",! b || m._data (b [d], "globalEval"))} işlevi Ab (a, b) {if (1 === b.nodeType && m.hasData (a)) {var c, d, e, f = m._data (a), g = m._data (b, f), h = f.events; eğer (h) {sil g.handle, g.events = {}; için (h in c) için (d = 0, e = h [ c] .length, e>; D ++) m.event.add (b, c, h: [c] [d])} g.data && (g.data = m.extend ({} g.data)) }} Bb (a, b) işlevi {var c, d, e; if (1 === b.nodeType) {if (c = b.nodeName.toLowerCase () ,! k.noCloneEvent && b [m.expando]) {e = m._data (b); (e.event'te d) için m.removeEvent (b, d, e.handle); b.removeAttribute (m.expando)} "script" === c && b.text! == a.text (xb (b) '.text = a.text, Yb (b)):? "nesne" === c (b.parentNode && (b.outerHTML = a.outerHTML), k.html5Clone ve! & A.innerHTML && m.trim (b.innerHTML) && (b.innerHTML = a.innerHTML)): "girdi" === c && W.test (a.type) (b.defaultChecked = b.checked = a?. ! kontrol b.value == a.value && (b.value = a.value)):? "seçeneği" === c b.defaultSelected = b.selected = a.defaultSelected :( "giriş" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)}} m.extend ({clone: ​​function (a, b, c) {var d, e, f, g, h, i = m.contains (a.ownerDocument a); if (k.html5Clone || m.isXMLDoc (a) || gb.test ( "<" + a.nodeName + ">") f = a.cloneNode (!? ! 0) :( tb.innerHTML = a.outerHTML, tb.removeChild (f = tb.firstChild))! (k.noCloneEvent && k.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || m .isXMLDoc (a))) (d = uB (f), h = uB (a) g = 0;! boş = (e = H [g]); ++ g) d [g] && Bb (e d [g];) boş = (e = H [g, (b) (c) (h = saat || ub (eğer a), d = d || uB (f), g = 0 ise ]) g ++) Ab (e, D [g]);else Ab (a, f); döndür d = ub (f, "script"), d.length> 0 && zb (d,! i && ub (a, "script")), d = h = e = null, f}, buildFragment: function (a, b, c, d) {için (varis, f, g, h, i, j, l, n = a. uzunluk, o = db (b), p = [], q = 0 n> q q ++) halinde (|| 0 === f f f = a [q],) halinde ( "nesne" === m.type (f)) m.merge (s, f.nodeType ? [f]: f); aksi halde (lb.test (f)) {h = h || o.appendChild (b.createElement ("div")), i = (jb.exec (f) || [ "", ""]) [1] .toLowerCase (), i = rb [i] || rb._default, h.innerHTML = l [1] + f.replace (ib "<$ 1> </ $ 2> ") + l [2], e = l [0]; ise (e -) h = h.lastChild;! (eğer k.leadingWhitespace && hb.test (f) && p.push (b.createTextNode (hb.exec ( f) [0])) ,! k.tbody) {f = "tablo"! == ı || kb.test (f) '? "<tablo>"! == l [1] || kb.test ( f?) 0: H: h.firstChild e = f && f.childNodes.length, (e ise -) m.nodeName (j = f.childNodes [e], "tbody") &&!j.childNodes.length && f.removeChild (j)} m.merge (s, h.childNodes), h.textContent = ""; iken (h.firstChild) h.removeChild (h.firstChild), h = o.lastChild} başka p.push (b.createTextNode (f)); h && o.removeChild (h), k.appendChecked || m.grep (ub (p, "giriş"), vb), q = 0; [q ++]) halinde ((d! || -1 === m.inArray (f, d)) && (g = m.contains (f.ownerDocument, f), h = uB (o.appendChild (f) , "script"), g && zb (h), c)) {e = 0; süre (f = h [e ++]) ob.test (f.type || "") && c.push (f)} return h = null, o}, cleanData: function (a, b) {için (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m .event.special;! boş = (d = l, bir [h]) h ++) halinde ((|| m.acceptData (d) 'b) && (f = d [i], g = && j f [f])) { if (g.events) (e.events e) n [e] a m.event.remove (d, e) için: m.removeEvent (d, e, g.handle); j [f] && (sil) j [f], l? d [i] siler: typeof d.removeAttribute! == K? d.removeAttribute (i): d [i] = null, c.push (f))}}}), m.fn.extend ({text: function (a) {return V (bu, function (a) {return void 0 === bir m.text (bu): this.empty () ekler ((bu [0] && bu [0] .ownerDocument || y) .createTextNode (a))}, boş bir, bağımsız değişkenler.. uzunluk)}, append: function () {return this.domManip (bağımsız değişkenler, işlev (a) {eğer (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = wb (bu, a); b.appendChild (a)}})}, prepend: function () {return this.domManip (bağımsız değişkenler, işlev (a) {if (1 === this.nodeType | | 11 === this.nodeType || 9 === this.nodeType) {var b = wb (this, a); b.insertBefore (a, b.firstChild)}})}, önce: function () { this.domManip işlevini döndür (argümanlar, işlev (a) {this.parentNode && this.parentNode.insertBefore (a, bu)})}, sonra: function () {return this.domManip (değişkenler, işlev (a) {this.parentNode && this. parentNode.insertBefore (a, this.nextSibling)})}, kaldırma: fonksiyonu (a,b) {için (var c, d = a? m.filter (a, this): bu, e = 0; null! = (c = d [e]); e ++) b || 1! == c. nodeType || m.cleanData (uB (c)), c.parentNode && (b && m.contains (c.ownerDocument, c) && zb (uB (c, "komut")), c.parentNode.removeChild (c)); dönüş this}, empty: function () {((var a, b = 0; null! = (a = this [b]); b ++) {1 === a.nodeType && m.cleanData (ub (a,! 1) ); while (a.firstChild) a.removeChild (a.firstChild); a.options && m.nodeName (a, "select") && (a.options.length = 0)} şunu döndürün}, clone: ​​function (a, b) {return a = null == a?! 1: a, b = null == b? a: b, this.map (function () {return m.clone (this, a, b)})}, html: function (a) {return V (bu, işlev (a) {var b = this [0] || {}, c = 0, d = this.length; eğer (void 0 === a) return 1 === b.nodeType? b.innerHTML.replace (fb, ""): void 0; if (! ("string"! = typeof a || mb.test (a) ||! k.htmlSerialize && gb.test ( a) ||! k.leadingWhitespace &Ve hb.test (a) '|| rb [(jb.exec (a)' || [ "", ""]) [1] .toLowerCase ()])) {a = a.replace (ib "<$ 1> <$ / 2> "); için {deneyin (d> c;! c ++) B = Bu [c] || {}, 1 === b.nodeType && (m.cleanData (uB (b, 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty (). append (a)}, null, a, arguments.length)}, replaceWith: function () {var a = arguments [0]; this.domManip (bağımsız değişkenler, işlev (b) {a = this.parentNode, m.cleanData (ub (this)), bir && a.replaceChild (b, this)}), a && (a.length || a.nodeType)? this: this.remove ()}, detach: function (a) {return this.remove (a,! 0)}, domManip: function (a, b) {a = e.apply ([] , a); var c, d, f, g, h, i, j = 0, l = bu. uzunluk, n = bu, o = l-1, p = a [0], q = m.isFunction ( p); eğer (q || l> 1 && "string" == p &&! k.checkClone && nb.test (p) 'nin tipini) eğer bunu döndürür.each (function (c) {var d = n.eq (c); q && ( a [0] = p.call (bu, c, d.html ())), d.domManip (a, b)};) (L && (i = m.buildFragment (a, bu [0] .ownerDocument, 1, bu), C = i.firstChild, 1 === i.childNodes.length && ( i = c), c)) {(g = m.map (uB (i, "komut"), Xb), f = g.length; l> j;! j ++) d = i, j == o && (d = m.clone (d, 0, 0), f && m.merge (g, ub (d, "komut"))!), b.call (bu [j], d, j); (f ) (h = gr [g.length-1] .ownerDocument, m.map (g, yb), j = 0, f> j, j ++), d = gr [j], ob.test (d.type | | ""!) && m._data (d, "globalEval") && m.contains (h, d) && (d.src m._evalUrl && m._evalUrl (d.src?): m.globalEval ((d.text | | d.textContent || d.innerHTML || ""). replace (qb, ""))); i = c = null} Döndür}}), m.each ({appendTo: "append", prependTo: "prepend", insertBefore: "önce", insertAfter: "after", replaceAll: "replaceWith"}, işlev (a, b) {m.fn [a] = işlev (a) {için (var c,? D! = 0, S = [], g = m (a) h = g.length-1, h> d = d ++), C = d === s, bu: this.clone (0), m (g [d]) [b] (c), f.apply (e, c.get ()); şunu döndürün. pushStack (e)}}); var Cb, Db = {}; Eb (b, c) {var d, e = m (c.createElement (b)). appendTo (c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle (e [0]))? d.display: m. css (e [0], "ekran"); e.detach (), f} işlevini döndürün Fb (a) {var b = y, c = Db [a]; dönüş c || (c = Eb (a, b), "none"! == c && c || (Cb = (Cb || m ("<iframe frameborder = '0' width = '0' height = '0' />")) appendTo (b.documentElement ), b = (Cb [0] .contentWindow || Cb [0] .contentDocument) .document, b.write (), b.close (), c = Eb (a, b), Cb.detach ()) , Db [a] = c), c}! Function () {var a; k.shrinkWrapBlocks = function () {eğer (null! = A), a; a =! 1; var b, c, d; return c = y.getElementsByTagName ( "vücut") [0], c && c.style? (b = y.createElement ( "div"),d = y.createElement ( "div"), d.style.cssText = "konumu: mutlak; sınır: 0; genişliği: 0; yükseklik: 0; en: 0, sol: -9999px", c.appendChild (d) .appendChild (b), typeof b.style.zoom! == K && (b.style.cssText = "- webkit-box-boyutlandırma: content-box; -moz-kutu-boyutlandırma: content-box; kutu-boyutlandırma: içerik kutu; görüntü: bloğu; marjı: 0; sınır: 0; doldurma: 1 piksel; genişliği: 1 piksel; zum: 1" , b.appendChild (y.createElement ( "div")) style.width =. "5px" , a = 3! == b.offsetWidth), c.removeChild (d), a): void 0}} (); var Gb = / ^ marj /, Hb = new RegExp ("^ (" + S + ") (?! px) [az%] + $", "i"), Ib, Jb, Kb = / ^ (üst | right | alt | solda) $ /;? a.getComputedStyle (Ib = function (a) { dönüş a.ownerDocument.defaultView.getComputedStyle (a, null)}, Jb = işlevi (a, b, c) {var d, e, f, g, h = a.style; return c = c || Ib (a ), g = c? c.getPropertyValue (b) || c [b]: geçersiz 0, c && (""! == g || m.contains (a.ownerDocument a) || (g = m.style (a, b)), Hb.test (g) && Gb.test (b) && (d = h.width e = h.minWidth, f = h.maxWidth h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), boşluk 0 === gg: g + ""}): y.documentElement.currentStyle && (Ib = fonksiyon (a) {return a.currentStyle}, Jb = fonksiyon (a, b, c) {var d, e, f, g, h = a.style ; dönüş c = c || Ib (a), g = c? c [b]: geçersiz 0, null == g && h && h [b] && (g = h [b]), Hb.test (g) &&! Kb .test (b) && (d = h.left e = a.runtimeStyle, f = e && e.left f && (e.left = a.currentStyle.left), h.left = "fontSize" === b? "1em": g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), geçersiz 0 === g? G + "" || "otomatik"}) ; fonksiyonu Lb (a, b) {return {get: function () {var c = a (); eğer (null! = c) c c dönünse void this.get silin: (this.get = b) .apply ( this, argümanlar)}}}! function () {var b,c, d, e, f, g, h; eğer (b = y.createElement ("div"), b.innerHTML = "<link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", d = b.getElementsByTagName (" a ") [0], c = d && d.style) {c.cssText =" float: left; opacity: .5 " k.opacity = "0.5" === c.opacity, k.cssFloat = !! c.cssFloat, b.style.backgroundClip = "içerik kutusu", b.cloneNode (! 0) .style.backgroundClip = "", k.clearCloneStyle = "içerik kutusu" === b.style.backgroundClip, k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, m.extend (k, {ReliableHiddenOffsets: function () {return null == g && i (), g}, boxSizingReliable: function () {return null == f && i (), f}, pixelPosition: function () {return null == e && i (), e}, ReliableMarginRight:function () {return null == h && i (), h}}); function i () {var b, c, d, i; c = y.getElementsByTagName ("body") [0], c && c.style && (b = y.createElement ( "div"), d = y.createElement ( "div"), d.style.cssText = "konumu: mutlak; sınır: 0; genişliği: 0; yükseklik: 0; en: 0, sol: -9999px "c.appendChild (d) .appendChild (b) b.style.cssText =" - webkit kutu boyutlandırma: sınır-box; -moz kutu boyutlandırma: sınır-kutu, kutu boyutlandırma: sınır box; görüntü: blok, kenar üstü:% 1; en: 1%; sınır: 1 piksel; doldurma: 1 piksel, genişlik:! 4 piksel; pozisyonu: "mutlak e = f = 1, h = 0, bir. getComputedStyle && (e = "1%" == (a.getComputedStyle (b ||), boş {}) ister üst, Rf = "4 piksel" === (a.getComputedStyle (b ||), boş {eni!.: "4 piksel"}) genişliği, i = b.appendChild (y.createElement ( "div")), i.style.cssText = b.style.cssText = "- webkit kutu boyutlandırma. içerik kutu; -moz box boyutlandırma: içerik kutu;kutu boyutlandırma: içerik kutu; görüntü: bloğu; marjı: 0; sınır: 0; doldurma: 0" , i.style.marginRight = i.style.width = "0", b.style.width = "1 piksel" h =! parseFloat ((a.getComputedStyle (i, sıfır) || {}). marginRight)), b.innerHTML = "<tablo> <tr> <td> </ td> <td> t </ td > </ tr> </ table>" i = b.getElementsByTagName ( "tD") kadar [0] .style.cssText = "kenar: 0; sınır: 0; doldurma: 0; görüntü: yok", g = 0 === i [0] .offsetHeight g && (i [0] .style.display = "" i [1] .style.display = "yok", g = 0 === i [0]. offsetHeight), c.removeChild (d))}}} (), m.swap = işlevi (a, b, c, d) {var e, f, g = {}; ] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []); için (b'de f) a.style [f] = g [f]; dönüş e}; var Mb = / alpha \ ([^)] * \) / i, Nb = / opaklık \ s * = \ s * ([^)] *) /, Ob = / ^ ( none | table (?! - c [ea]). +) /, Pb = yeni RegExp ("^ (" + S + ") (. *) $", "i"), Qb = yeni RegExp ("^ ([+ -]) = (" + S + ")", "i"), Rb = {position: "mutlak", görünürlük: "gizli", görüntüleme: "blok"}, Sb = {letterSpacing: "0", fontWeight: "400"}, Tb = ["Webkit", "O", "Moz", "ms"]; işlev Ub (a, b) {eğer (a'daki b) b değerini döndürün; var c = b.charAt (0) .UpperCase () + b.slice (1), d = b, e = Tb.length; iken (e -) ise (b = Tb [e] + c, b a) içinde geri dönüş b; d} işlevini geri döndür Vb (a, b) {için (var c, d, e, f = [], g = 0, h = a. uzunluğu; h> g? g ++) d = bir [g], d.style &&, c = d.style.display b (f [g] || "yok ([g] = m._data (d, "olddisplay" f) "! == c || (d.style.display =" ")," "=== d.style.display && U (d) '&& (f [g] = m._data (d," olddisplay", Fb ( d.nodeName)))) :( e = U (d), (c && "yok" == c || e) && m._data (d, "olddisplay" e c:!? m.CSS (d, "ekran")))), (g = 0; h> g g ++) d = bir [g], d.style && (b && "yok" == d.style.display && ""! == d.style.display || (d.style.display = b? f [g] || "": "yok")); a} işlevini döndürün Wb (a, b, c) {var d = Pb .exec (b); dönüş d? Math.max (0, d [1] - (c || 0)) + (d [2] || "px"): b} fonksiyon Xb (a, b, c , d, e) {için (var f = c === (d? "sınır": "içerik")? 4: "genişlik" === b? 1: 0, g = 0; 4> f; f + = 2) "kenar" === c && (g + = m.css (a, c + T [f] ,! 0, e)) D? ( "içerik" === c && (g- = m.css (a, "doldurma" + T [f] ,! 0, e)), "sınır"! == c && (g- = m.css (a, "sınır" + T [f] + "En" ,! 0, e))) :( g + = m.css (a, "doldurma" + T [f] ,! 0, d), "doldurma"! == c && (g + = m.css (a, "sınır" + T [f] + "Genişlik",! 0, e)))), döndür g} işlevi Yb (a, b, c) {var d =! 0, e = "genişlik "=== b a.offsetWidth: a.offsetHeight, f = Ib, (a), g = k.boxSizing &&" sınır kutusu "=== m.css (a,"! boxSizing", 1, f) (0> = e || boş == e) eğer {durumunda (e = Jb (a, b, f), (0> e || boş == e) && (e = a.style [b]) , Hb.test (e)) dönüş e; d = g && (k.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} return e + Xb (a a, b, c || (g "sınır": "içerik"), D, F) + "piksel"} m.extend ({cssHooks: {opaklık: {elde: fonksiyonu (a, b) {(b ) {var c = Jb (a, "opaklık"); "" === c? "1": c}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink: 0, fontWeight: 0, lineHeight: 0, donukluk: 0, sipariş: 0, yetim: 0, dul: 0, zIndex: 0, yakınlaştırma: 0}, cssProps: {" float ": k.cssFloat?" cssFloat ":" styleFloat "}, stil: işlev (a, b, c, d) {if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e f,g, h = m.camelCase, (b), I = a.style (b = m.cssProps [h] || (eğer m.cssProps [h] = Ub (i, h)) g = m.cssHooks [b] || m.cssHooks [h], void 0 === c) g && "get" i döndürür g && void 0! == (e = g.get (a,! 1, d))? e: i [ b]; eğer (f = c, "string" === f && (e = Qb.exec (c)) && (c = (e [1] +1) * e [2] + parseFloat (m.css (a, b)), f = "sayı"), boş! = c && c === c && ( "sayı"! == f || m.cssNumber [h] || (c + = "piksel"), k. clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (i [b] = "devralır"),! (g && void 0 === (g && "set") = g.set (a, c, d))))) deneyin {i [b] = c} yakala (j) {}}}, css: işlevi (a, b, c, d) {var e, f , g, h = m.camelCase (b); dönüş b = m.cssProps [h] || (m.cssProps [h] = Ub (a.style, h)), g = m.cssHooks [b] | | m.cssHooks [h], g && g && (f = g.get (a,! 0, c)) 'da "olsun", void 0 === f && (f = Jb (a, b, d)), "normal "=== f &&b Sb && (f = Sb [b])," "=== c || c? (e = parseFloat (f), c ===! 0 || m.isNumeric (e)? e || 0 f) f}}), m.each ([ "yükseklik", "genişlik"], fonksiyon (a, b) {m.cssHooks [b] = {elde: fonksiyonu (a, c, d) {return c? Ob.test (m.css (a, "display")) && 0 === a.offsetWidth? m.swap (a, Rb, function () {return Yb (a, b, d) }): Yb (a, b, d): geçersiz 0}, set: function (a, c, d) {var e = d && Ib (a); return Wb (a, c, d? Xb (a, b, d k.boxSizing && "border-box" === m.css (a, "boxSizing", 1, e!), e): 0)}}}), k.opacity || (m.cssHooks.opacity = {get: function (a, b) {return Nb.test ((b && a.currentStyle? a.currentStyle.filter: a.style.filter) || "") ?. 01 * parseFloat (RegExp. $ 1) + " ": b?" 1 ":" "}, set: function (a, b) {var c = a.style, d = a.currentStyle, e = m.isNumeric (b)?" alpha (opacity = "+ 100 * b + ")": "",f = d && d.filter || c.filter || ""; ( "=== b> = 1 || b) c.zoom = 1," && "" === m.trim (f.replace (Mb , "")) && c.removeAttribute && (c.removeAttribute ( "filtre"), "" === b || d &&! d.filter) || (c.filter = Mb.test (f)? f.replace ( Mb, e): f + "" + e)}}), m.cssHooks.marginRight = Lb (k.reliableMarginRight, function (a, b) {return b? M.swap (a, {ekran: "satır içi blok "}, Jb, [a," marginRight "]): void 0}), m.each ({margin:" ", dolgu:" ", sınır:" Genişlik "}, işlev (a, b) {m. cssHooks [a + b] = {genişlet: işlev (c) {için (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; 4 > d; d ++) e [a + T [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Gb.test (a) || ( m.cssHooks [a + b] .set = Wb)}), m.fn.extend ({css: function (a, b) {dönüş V (bu, işlev (a, b, c) {var d, e f = {}, g = 0; eğer (m.isArray (b)) {(d ​​= l Ib, (a), e = b.length için, e> g g ++) f [b [g]] = m.css (a, b: [g] ,! 1, d, ); return f} return void 0! == c? m.style (a, b, c): m.css (a, b)}, a, b, arguments.length> 1)}, göster: function ( ) {return Vb (this,! 0)}, hide: function () {return Vb (this)}, toggle: function (a) {return "boolean" == typın a? a? this.show (): this .hide (): this.each (function () {U (bu)? m (bu) .show (): m (bu) .hide ()})}}); işlev Zb (a, b, c, d, e) {yeni Zb.prototype.init (a, b, c, d, e) döndürün} m.Tween = Zb, Zb.prototype = {yapıcı: Zb, init: function (a, b, c, d , e, f) {this.elem = a, this.prop = c, this.easing = e || "salınım", this.options = b this.start = this.now = this.cur (), bu .end = d, this.unit f || = (m.cssNumber [c] "": "piksel")function () {return Vb (this)}, toggle: function (a) {return "boolean" == bir? a? a? this.show (): this.hide (): this.each (function () {U (this)? m (this) .show (): m (this) .hide ()})}}); işlev Zb (a, b, c, d, e) {return new Zb.prototype.init (a a, b, c, d, e)} m.Tween = Zb Zb.prototype = {yapıcı: Zb init: fonksiyonu (a, b, c, d, e, f) {this.elem = a, bu. (m || this.unit = f, = c, this.easing = e || "salınım", this.options = b, this.start = this.now = this.cur (), this.end = d prop .cssNumber [c] "": "piksel")function () {return Vb (this)}, toggle: function (a) {return "boolean" == bir? a? a? this.show (): this.hide (): this.each (function () {U (this)? m (this) .show (): m (this) .hide ()})}}); işlev Zb (a, b, c, d, e) {return new Zb.prototype.init (a a, b, c, d, e)} m.Tween = Zb Zb.prototype = {yapıcı: Zb init: fonksiyonu (a, b, c, d, e, f) {this.elem = a, bu. (m || this.unit = f, = c, this.easing = e || "salınım", this.options = b, this.start = this.now = this.cur (), this.end = d prop .cssNumber [c] "": "piksel")Şimdi this.unit f || =, this.cur (), this.end = D = (m.cssNumber [c] "": "piksel")Şimdi this.unit f || =, this.cur (), this.end = D = (m.cssNumber [c] "": "piksel")
}, cur: function () {var a = Zb.propHooks [this.prop]; bir && a.get? a.get (this) döndürün: Zb.propHooks._default.get (this)}, run: function (a) {var b, c = Zb.propHooks [this.prop]; şunu this.pos = b = this.options.duration? m.easing [this.easing] (a, this.options.duration * a, 0,1 , this.options.duration): a, this.now = (this.end-this.start) B * B + this.start, this.options.step && this.options.step.call (this.elem, this.now, Bu), c && c.set c.set (bu):? Zb.propHooks._default.set (bu), bu}}, Zb.prototype.init.prototype = Zb.prototype, Zb.propHooks = {_ default: {get : function (a) {var b; return null == a.elem [a.prop] || a.elem.style && null! = a.elem.style [a.prop]? (b = m.css (a. ! elem, a.prop ""), b && "otomatik" == b,: 0): a.elem [a.prop]}, set: olan (a) {m.fx.step [a.prop ] m.fx.step [a.prop] (a):! a.elem.style && (boş = a.elem.style [m.cssProps [a.prop]? [a] || m.cssHooks.prop]) m.style (a.elem, a.prop, a.now + a.unit): a.elem [a.prop] = a.now}}} Zb.propHooks.scrollTop = Zb.propHooks .scrollLeft = {grubu: olan (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}} m.easing = {doğrusal: olan (a) {dönüş a}, swing: function (a) {return.5-Math.cos (a * Math.PI) / 2}}, m.fx = Zb.prototype.init, m.fx.step = {}; var $ b, _b, ac = / ^ (?: toggle | show | hide) $ /, bc = yeni RegExp ("^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $ "," i "), cc = / queueHooks $ /, dc = [ic], ec = {" * ": [işlev (a, b) {var c = this.createTween (a, b), d = c.cur (), e = bc.exec, (b), f = e && e [cos (a * Math.PI) / 2}}, m.fx = Zb.prototype.init, m.fx.step = {}; var $ b, _b, ac = / ^ (?: toggle | show | hide ) $ /, bc = yeni RegExp ("^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $", "i"), cc = / sıraHooks $ / , dc = [ic], ec = {"*": [fonksiyon (a, b) {var c = this.createTween (a, b), d = c.cur (), e = bc.exec (b) f = e && e [cos (a * Math.PI) / 2}}, m.fx = Zb.prototype.init, m.fx.step = {}; var $ b, _b, ac = / ^ (?: toggle | show | hide ) $ /, bc = yeni RegExp ("^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $", "i"), cc = / sıraHooks $ / , dc = [ic], ec = {"*": [fonksiyon (a, b) {var c = this.createTween (a, b), d = c.cur (), e = bc.exec (b) f = e && e [3] || (m.cssNumber [a] "": "piksel"), g = (m.cssNumber [a] || "! Piksel" == f && + d) && bc.exec (m.css (C .elem a)), h = 1, 20 =;! (g && g [3] == f) {f = f || g [3], e = e || [], g = + d | | 1; h = h || ".5" yapın, g / = h, m.style (c.elem, a, g + f); süre (h! == (h = c.cur () / d ) && 1! == h && - i)} return e && (g = c.start = + g || + d || 0, c.unit = f, c.end = e [1]? G + (e [1] ] +1) * e [2]: + e [2]), c}]}; fonksiyon fc () {setTimeout işlevini döndür (işlev () {$ b = geçersiz 0}), $ b = m.now () } gc (a, b) işlevi {var c, d = {yükseklik: a}, e = 0; (b = b? 1: 0; 4> e; e + e = 2-b) c = T [e] , d ["marj" + c] = d ["dolgu" + c] = a; dönüş b && (d.opacity = d.width = a), d} fonksiyon hc (a, b, c) {için (var = 0, c = e.length f d, e = (ec [b] || []) concat (ec [ "*"]);. g> f f ++) eğer (D = e [f]. call (c, b, a)) d} işlevini döndürür ic (a, b, c) {var d, e, f, g, h, i, j, l, n = bu, o = {}, p = a.style, q = a.nodeType && U (a), r = m._data (a, "fxshow") = 0 h.unqueued c.queue || (h = m._queueHooks (a, "fx"), boş == h.unqueued && (i = h.empty.fire, h.empty.fire = fonksiyonu ( ) {h.unqueued || i ()}) ++ h.unqueued, n.always (fonksiyonu () {n.always (fonksiyonu () {h.unqueued -, m.queue (a, "fx"). uzunluk || h.empty.fire ()})})), 1 === a.nodeType && ("b" deki "yükseklik" b) ve "(" c.overflow = [p.overflow, s. overflowX, p.overflowY], j = m.css (a, "ekran"), I = "yok" === j m._data (a, "olddisplay") || Fb (a.nodeName): j "inline" === l && "hiçbiri" === m.css (a, "şamandıra") && (k.inlineBlockNeedsLayout && "satır içi" == Fb (a.nodeName) p.zoom = 1:!? s. ekran = "satır içi blok")), c.overflow && (p.overflow = "gizli", k.shrinkWrapBlocks () || n.always (fonksiyonu () {p.overflow = c.overflow [0], s. overflowX = c.overflow [1], s.overflowY = c.overflow [2]})); (d in b) için (e = b [d], ac.exec (e)) {eğer (sil [b] d, f = f || "toggle "=== e, e === (q?" hide ":" show ")) {if (" show "! == e ||! r || void 0 === r [d]) devam edin; q =! 0} o [d] = r && r [d] || m.style (a, d)} else j = void 0; eğer (m.isEmptyObject (o)) "inline" === ("none" === j? Fb (a.nodeName): j) && (p.display = j); r && (q = r.hidden) 'da {r? "gizli": r = m._data (a, "fxshow "{}), f && (r.hidden = q), q m () .show ():? n.done (fonksiyonu () {m, (a) '.hide ()}), n.done ( function () {var b; m._removeData (a, "fxshow"); (b in o) m.style (a, b, o [b])}) için; (d in o) g = hc ( q? r [d]: 0, d, n), r içinde r || (r [d] = g.start, q && (g.end = g.start, g.start = "width" === d || "height" === d? 1: 0))}} işlevi jc (a, b) {var c, d, e, f, g; (a içinde c) için (d = m.camelCase ( c) f e = b [d] = a [c], m.isArray (f) && (e = f [1],f = a [c] = f [0]), c! == d && (a [d] = f, bir [c] sil), g = m.cssHooks [d], g && "genişlet", g) { f = g.expand (f), bir [d] öğesini silin; (c in f) c için bir || (a [c] = f [c], b [c] = e)} başkasında b [d] = e} kc fonksiyonu (a, b, c) {var d, e, f = 0, g = dc.length, h = m.Deferred (). always (function () {delete i.elem}), i = function () {if (e)!!;; (var b = $ b || fc () için, c = Math.max (0, j.startTime + j.duration-b), d = c / j .duration || 0, f = 1-d, g = 0, i = j.tweens.length; i> g; g ++) j.tweens [g] .run (f); h.notifyWith (a, [ j f-c]), 1> f && c: (h.resolveWith (a, [j]) ,! 1)}, j = h.promise ({elem: a, sahne: m.extend ({} , b), seçmesi: m.extend (0,! {specialEasing: {}} c) originalProperties b, originalOptions: c, startTime: $ b || fc (), süre: c.duration, araların: [ ], createTween: function (b, c) {var d = m.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); push (d), d}, stop: işlev (b) {var c = 0, d = b? j.tweens.length: 0; eğer (e) bunu döndürürse;(e =! 0; d> c; c ++) j.tweens [c] .run (1) 'e dönün, b' h.çoğalmakla (a, [j, b]): h.rejectWith (a, [j, b]), bu}}), k = j.props g> f;: f ++) ise (X = dC [f] .call (j, bir k (jc (k, j.opts.specialEasing) için , j.opts)) d döndür; m.map (k, hc, j), m.isFunction (j.opts.start) && j.opts.start.call (a, j), m.fx.timer ( m.extend (i {elem: a, Anim: j, kuyruğu: j.opts.queue})), j.progress (j.opts.progress) .done (j.opts.done, j.opts.complete ) .fail (j.opts.fail) .always (j.opts.always)} m.Animation = m.extend (KC, {tweener: fonksiyonu (a, b)? {m.isFunction, (a), (b = a, a = ["*"]): a = a.split (""); (var c, d = 0, e = a.length; e> d; d ++) c = a [d], ec [c] = ec [c] || [], ec [c] .unshift (b)}, ön-filtre: fonksiyonu (a, b) {b dc.unshift (a) dc.push (a)}} ), m.speed = fonksiyon (a, b, c) {var d = a & & "nesne" == bir? m.extend ({}, a) yazın: {complete: c ||! c && b || m.isFunction (a) && bir, süre: a, hafifletilmesi: c && b || b &&!m.isFunction (b) && b}; dönüş d.duration = m.fx.off? 0: "sayı" == yazılan d.duration? d.duration: d.duration: m.fx.speeds? m.fx. hızları [d.duration]: m.fx.speeds._default, (boş == d.queue || d.queue === 0!) && (d.queue = "fx"), d.old = d'dir. tam d.complete = fonksiyonu () {m.isFunction (d.old) && d.old.call (bu), d.queue && m.dequeue (bu, d.queue)}, d} m.fn.extend ( {fadeTo: function (a, b, c, d) {this.filter (U) .css ("opacity", 0) .show (). end () komutunu döndür. animate ({opacity: b}, a, c , d)}, animate: fonksiyon (a, b, c, d) {var e = m.isEmptyObject (a), f = m.speed (b, c, d), g = fonksiyon () {var b = kc (bu, m.extend ({}, a), f); (e || m._data (bu, "bitiş")) && b.stop (! 0)}; return g.finish = g, e | | f.queue ===! 1? this.each (g): this.queue (f.queue, g)}, stop: işlev (a, b, c) {var d = işlev (a) {var b = a.stop; silme a.stop, b (c)}; return "string"! = typeof a &&(c = b, b = a, a = geçersiz 0), b && a! ==! 1 && this.queue (a || "fx", []), this.each (function () {var b =! 0, e = null! = a & a + "queueHooks", f = m. zamanlayıcılar, g = m._data (bu); eğer (e) g [e] && g [e] .stopu && d (g [e]); g) f [e] && g [e] .stop && cc.test (e) && d (gr [e]); (e = f.length, e -;) [e] .elem == Bu ön || ! boş bir && f [e] .queue = == bir || (f [e] .anim.stop (c), b = 1 olduğunda, f.splice (yani, 1)!)! (! b || c) && m.dequeue (this, a)})}, finish: function (a) {return a! ==! 1 && (a = a || "fx"), this.each (function () {var b, c = m._data (bu), D = c [a + "sıra"] = m.timers, c = k e = c [a + "queueHooks"], d d.length: 0 (c.finish = mı?! 0, m.queue (bu, bir, []), e && e.stop && e.stop.call (bu, 0!), b = f.length b -;) [b] .elem f === Bu && f [ b] .queue === bir && ([b] .anim.stop (0), f.splice (b, f 1)!), (b = 0; g> b, b ++) d [b] &&d [b] .finish && d [b] .finish.call (this); sil c.finish})}}), m.each (["değiştir", "göster", "gizle"], işlev (a, b ) {var c = m.fn [b]; m.fn [b] = fonksiyon (a, d, e) {return null == a || "boolean" == typeof a? c.apply (this, arguments ): this.animate (gc (b, 0!), a, D, e)}}), m.each ({slideDown: gc ( "") için, slideUp: gc ( "gizlemek"), slideToggle: gc ( "geçiş"), fadeIn: {opaklık: "göster"}, fadeOut: {opaklık: "gizlemek"} fadeToggle: {opaklık: "geçiş"}} fonksiyonu (a, b) {m.fn [a] = function (a, c, d) {this.animate (b, a, c, d)}} döndür, m.timers = [], m.fx.tick = function () {var a, b = m .timers, c = 0; için ($ b = m.now () c <b.length c ++), a = b [c], a () || b [c] == bir || b!. splice (c -, 1); b.length || m.fx.stop (), $ b = geçersiz 0}, m.fx.timer = function (a) {m.timers.push (a), a ? () m.fx.start (): m.timers.pop ()}, m.fx.interval = 13, m.fx.start = fonksiyonu () {_ b || (_b = setInterval (m.fx.hızlı, 600:, m.fx.interval))}, m.fx.stop = fonksiyonu () {clearInterval (_b), _ b = boş} m.fx.speeds = {yavaş kene 200, _default: 400} , m.fn.delay = function (a, b) {return a = m.fx? m.fx.speeds [a] || a: a, b = b || "fx", this.queue (b, function (b, c) {var d = setTimeout (b, a); c.stop = function () {clearTimeout (d)}})}, function () {var a, b, c, d, e; b = y.createElement ("div"), b.setAttribute ("className", "t"), b.innerHTML = "<link/><table> </table> <a href='/a'> a < / a> <input type = 'checkbox' /> ", d = b.getElementsByTagName (" a ") [0], c = y.createElement (" select "), e = c.appendChild (y.createElement (" seçeneği ")), bir = b.getElementsByTagName (" giriş ") [0], d.style.cssText =" En: 1 piksel", k.getSetAttribute = "t" == b.className, k.style = / üst / .test (d.getAttribute ( "tarzı")), k.hrefNormalized = "/ a" === d.getAttribute ( "href"), k.checkOn = !! a.value, k.optSelected = e.selected, k.enctype = !! y.createElement ( "form") .enctype, c.disabled =! 0, k.optDisabled =! e.disabled a = y.createElement ( "giriş"), a.setAttribute ( "değeri", ""), k.input = "" == = a.getAttribute ("değer"), a.value = "t", a.setAttribute ("type", "radio"), k.radioValue = "t" === a.value} (); var lc = / \ r / g; m.fn.extend ({val: function (a) {var b, c, d, e = bu [0]; {if (arguments.length), d = m.isFunction (a değerini döndürür. ), this.each (function (c) {var e; 1 === this.nodeType && (e = d? a.call (this, c, m (bu) .val ()): a, null == e ? e = "": "sayı" == e? e + = "": m.isArray (e) && (e = m.map (e, işlevi (a) {return null == a? "": a + ""})), b = m.valHooks [this.type] || m.valHooks [bu.nodeName.toLowerCase ()], b && b && void 0 "=" b "set" (bu, e, "değer") || (this.value = e))}); .valHooks [e.type] || m.valHooks [e.nodeName.toLowerCase ()], b && b && void 0 'da "olsun! == (c = b.get (e," değer "))? c :( c = e.value, "string" == typeof c? c.replace (lc, ""): null == c? "": c)}}}), m.extend ({valHooks: {option: { get: function (a) {var b = m.find.attr (a, "değer"); return null! = b? b: m.trim (m.text (a))}}, şunu seçin: {get: işlev (a) {için (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0> e, g = f? null: [ ] h = f e + 1: d.length, i = 0> e H, f, e:? 0! h> i; i ++) (c = D [i], (c.selected && i! == e || (? k.optDisabled c.disabled: boş == c.getAttribute ( "özürlü")) || c.parentNode.disabled && m.nodeName (c.parentNode, "OPTGROUP"))) {if ( b = m (c).val (), f) dönüş b; g.push (b)} dönüş g}, set: function (a, b) {var c, d, e = a.options, f = m.makeArray (b), g = e.length; iken (g -) ise (d = e [g], m.inArray (m.valHooks.option.get (d), f)> = 0) deneyin {d.selected = c =! 0} catch (h) {d.scrollHeight} else d.selected =! 1; c || (a.selectedIndex = -1), e}}}}), m.each (["radio", "onay kutusu) "], function () {m.valHooks [this] = {set: function (a, b) {return m.isArray (b)? a.checked = m.inArray (m (a) .val (), b )> = 0: void 0}}, k.checkOn || (m.valHooks [this] .get = function (a) {return null === a.getAttribute ("değer")? "On": a. değer})}); var mc, nc, oc = m.expr.attrHandle, pc = / ^ (?: kontrol | seçili) $ / i, qc = k.getSetAttribute, rc = k.input; m.fn. extend ({attr: function (a, b) {return V (this, m.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {m .removeAttr (this, a)})}}), m.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType;if (a && 3! == f && 8! == f && 2! == f) a.getAttribute === K typ m.prop (a, b, c) türünü döndürün :( 1 === f && m.isXMLDoc (a) || (b = b.toLowerCase (), d = m.attrHooks [b] || (m.expr.match.bool.test (b)? nc: mc)), geçersiz 0 === c? d && "get" d && null! == (e = d.get (a, b))? e: (e = m.find.attr (a, b), null == e? void 0: e): null! == c ? d && "set" in & & void 0! == (e = d.set (a, c, b))? e: (a.setAttribute (b, c + ""), c): void m.removeAttr (a, b))}, removeAttr: function (a, b) {var c, d, e = 0, f = b && b.match (E); eğer (f && 1 === a.nodeType) ise (c = f [e ++] a) d m.propFix [c] || c m.expr.match.bool.test (c) rC && qc || pc.test (c) [d] = 1:?!?! a [m.camelCase ! m.attr (a, c, ""), a.removeAttribute (? qc c: ​​d)}, attrHooks: {türü: {grubu - ( "varsayılan" + c)]] = 1 [d =: fonksiyonu (a, b) {if (! k.radioValue && "radyo" === b && m.nodeName (a, "giriş")) {var c = a.value; a.setAttribute ("type", b) döndür, c && (a.value = c), b}}}}}), nc = {set: function (a, b, c) {return b ===! 1? m.removeAttr (a, c): rc && qc ||! pc.test (c)? a.setAttribute (! qc && m.propFix [c] || c, c): a [m.camelCase ( "varsayılan -" + c) ']! a [c] = 0, c}} m.each (m.expr.match.bool.source.match (/ \ + / g ağırlık), fonksiyon = (a, b) {var c = oc [b] || m.find.attr; oc [b] = rc && qc ||! pc.test (b)? fonksiyonu (a, b, d) {var e, f d dönüşü || (f = oc [b], oc [b] = e, e = null! = c (a, b, d)? b.toLowerCase (): null, oc [b] = f), e}: function (a, b, c) {return c? void 0: a [m.camelCase ("varsayılan -" + b)]? b.toLowerCase (): null}}), rc && qc || (m. attrHooks.value = {set: function (a, b, c) {return m.nodeName (a, "giriş")? void (a.defaultValue = b): mc && mc.set (a, b, c)}}) , qc || (mc = {set: function (a, b, c) {var d = a.getAttributeNode (c); return d || a.setAttributeNode (d = a.ownerDocument.createAttribute (c)), d .değer = b + = "", "değer" === c || b === a.getAttribute (c)? b: void 0}}, oc.id = oc.name = oc.coords = function (a, b, c) {var d; c? void 0 döndürür: (d = a.getAttributeNode (b)) && ""! == d.value? d.value: null}, m.valHooks.button = {get: function (a, b) {var c = a.getAttributeNode (b); c && c.specified? c.value: void 0} döndür, set: mc.set}, m.attrHooks.contenteditable = {set: function (a, b, c) {mc.set (a, ""?! === b, 1: b, c)}} m.each ([ "genişlik", "yükseklik"], fonksiyon (a, b) {m, .attrHooks [b] = {set: function (a, c) {return "" === c? (a.setAttribute (b, "otomatik"), c): void 0}}})), k.style || (m.attrHooks.style = {get: function (a) {return a.style.cssText || void 0}, set: function (a, b) {return a.style.cssText = b + ""}} ); var sc = / ^ (?: input | select | textarea | button | object) $ / i, tc = / ^ (?: a | area) $ / i; m.fn.extend ({prop: function ( a, b) {V döndürür (bu, m.prop, a, b,arguments.length> 1)}, removeProp: function (a) {return a = m.propFix [a] || a, this.each (function () {deneyin {this {this [a] = boşluk 0, şunu silin [a ]} mandalı (b) {}})}}), m.extend ({propFix: { "için": "htmlFor", "sınıfı": "sınıfadı"} prop: fonksiyonu (a, b, c) { var d, e, f, g = a.nodeType; eğer (a && 3! == g && 8! == g && 2! == g) f = 1! == g ||! m.isXMLDoc (a), f && (b = m.propFix [b] || b, e = m.propHooks [b]), geçersiz 0! == c? e && "set" e && geçersiz 0! == (d = e.set (a, c, b ))? d: a [b] = c: e && e && null'da "olsun" = = (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = m.find.attr (a, "tabindex"); dönüş b? parseInt (b, 10): sc.test (a.nodeName) || tc.test (a.nodeName) && a .href 0: -1}}}}), k.hrefNormalized || m.each ([ "href", "src"], fonksiyon (a, b) {m.propHooks [b] = {elde: işlevi (a) {dönüş a.getAttribute (b, 4)}}}), k.optSelected || (m.propHooks.selected = {get: function (a) {var b = a.parentNode; dönüş b && (b.selectedIndex, b.parentNode && b.parentNode) .selectedIndex), boş}}), m.each ([ "tabIndex", "salt okunur", "maxLength", "cellSpacing", "cellpadding", "rowSpan", "birleşmiş satır", "USEMAP", "frameborder", "contentEditable"], function () {m.propFix [this.toLowerCase ()] = this}), k.enctype || (m.propFix.enctype = "kodlama"); var uc = / [\ t \ r \ n \ f] /g;m.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == bir && a; if (m.isFunction (a)) this.each (fonksiyon (b) {m (this) .addClass (a.call (this, b, this.className)))}) döndürün; .) (b = (a || "") için eşleşme (E) || [], i> h, h ++) (c = bu [h] d = 1 === c.nodeType && (c.className? ("" + c.className + "")) .replace (uc, ""): "")) {f = 0; while (e = b [f ++]) d.indexOf ("" + e + "")) <0 && (d + = e + ""); g = m.trim (d), c.className! == g && (c.className = g)} bunu geri gönder}, removeClass: function (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == bir && a yazın; eğer (m.isFunction (a)) this.each (fonksiyon, (b) {m (bu) .removeClass (a.call (bu, b, this.className))}); eğer b = (a || ((j) "") eşleşme (E) |. | []; i> h; h ++) eğer (c = bu [h], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (uc, "" ): "")) {f = 0; süre (e = b [f ++]) süre (d.indexOf ("" + e + "")> = 0) d = d.replace ("" + e + "", ""); g = a? m.trim (d): "", c.className! == g && (c.className = g)} bunu döndür}, toggleClass: function (a, b) {var c = typeof a; "boolean" döndürün == typeof b & & "string" === c? b? this.addClass (a): .removeClass (a): this.each (m.isFunction (a) fonksiyonu (c) {m (bu) .toggleClass (a.call (bu, c, this.className, b), b)}: fonksiyonu ( ) {if ("string" === c) {varb, d = 0, e = m (bu), f = a.match (E) || []; iken (b = f [d ++]) e ? .hasClass (b) e.removeClass (b): e.addClass (b)} başka (c === K || "boole" === c) && (this.className && m._data (bu, "__ className__" , this.className), this.className = this.className || bir === 1 "!?": m._data (bu, "__ className __") || "")})}, hasClass: function (a) {(var b = "" + a + "", c = 0, d = this.length; d> c; c ++) eğer (1 === this [c] .nodeType && ("" + this [c]. className + "") .replace (uc, "") .indexOf (b)> = 0) dönüş!0; return! 1}}), m.each ("netleme odağını odakta yükle odakla bulanıklık yeniden yükle kaydırma kaldır tıklama dblclick mousedown mouseup mousemove mouseover mouseout fare merkezi mouseleave değişiklik seçin keydown gönderme keypress keyup hata bağlam menüsü" .split (""), işlev (a , b) {m.fn [b] = fonksiyon (a, c) {return arguments.length> 0? this.on (b, null, a, c): this.trigger (b)}}), m. fn.extend ({hover: function (a, b) {return this.mouseenter (a) .mouseleave (b || a)}, bağlama: function (a, b, c) {return this.on (a, null , b, c)}, unbind: function (a, b) {return this.off (a, null, b)}, delege: function (a, b, c, d) {return this.on (b, a , c, d)}, undelegate: function (a, b, c) {return 1 === arguments.length? this.off (a, "**"): this.off (b, a || "* * ", c)}}); var vc = m.now (), wc = / \? /, xc = / (,) | (\ [| {) | (} |]) |" (?: [ ^ "\\\ r \ n] | \\ [" \\\ / bfnrt] | \\ u [\ da-fA-F] {4}) * "\ s * :? | doğru | yanlış | boş | ? - (?! 0 \ d) \ d + (: \?.\ d + |) (?: [eE] [+ -]? \ d + |) /g;m.parseJSON=function (b) {eğer (a.JSON && a.JSON.parse), a.JSON.parse (b + "döndürür. "); var c, d = null, e = m.trim (b +" "); e &&! m.trim (e.replace (xc, function (a, b, e, f)) {dönüş c && b && (d = 0), 0 === d? A: (c = e || b, d + =! F-! E, "")}))? İşlev ("return" + e) ​​(): m.error (" Geçersiz JSON: "+ b)}, m.parseXML = function (b) {var c, d; eğer (! B ||" string "! = B = typeof b) null döndürür, {a.DOMParser? (D = new 'ı deneyin. DOMParser, c = d.parseFromString (b, "text / xml")) :( c = yeni ActiveXObject ("Microsoft.XMLDOM"), c.async = "false", c.loadXML (b))} catch (e ) {c = void 0} c && c.documentElement &&! c.getElementsByTagName ("parsererror") döndürür. uzunluk || m.error ("Geçersiz XML:" + b), c}; var yc, zc, Ac = / #. * $ /, Bc = / ([? &]) _ = [^ &] * /, Cc = / ^ (. *?): [\ T] * ([^ \ r \ n] *) \ r? $ / g, Dc = / ^ (?:. Uygulamanın | | app-storage | + Hakkındaki - uzantısı | dosya | res | widget): $ /, Ec = / ^ (?: GET | BAŞLIK) $ / Fc = / ^ \ / \ // Gc = / ^ ([\ w + -.] +:) (: \ / \ / (:? [? ^ \ / #] * '|) ([^ \ / #:] *) (:: (\ . d +) |) |) / Hc = {}, Ic = {}, Jc = "* /" concat ( "*"); try {zc = location.href} catch (Kc) {zc = y.createElement ("a"), zc.href = "", zc = zc.href} yc = Gc.exec (zc.toLowerCase ()) || []; işlev Lc (a) {return işlevi (b, c) { "string"! = typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). match (E) || []; if (m.isFunction (c ? |)) ise (X = F [e ++]) "+" === d.charAt (0) (X = d.slice (1) || "*", (a [D] bir [d] = | []). vites değiştirme (c)) :( a [d] = a [d] || []) .tç (c)}} işlevi Mc (a, b, c, d) {var e = {} , f = a === Ic; g (h) işlevi {var i; dönüş e [h] =! 0, m.each (a [h] || [], işlevi (a, h) {var j = h (b, c, d); "string"! döndür = = typeof j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} döndür g (b.dataTypes [0]) ||!e ["*"] && g ("*")} işlevi Nc (a, b) {var c, d, e = m.ajaxSettings.flatOptions || {}; (b'deki d) için geçersiz 0! == b [d] && ((e [d]? a: c || (c = {})) [d] = b [d]); döndür c && m.extend (! 0, a, c), a} işlevi Oc (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), geçersiz 0 === e && (e = a.mimeType || b.getResponseHeader ("Content-Type")); (e) için (h içinde g) eğer (h [g] && h [g] .test (e)) {i.unshift (g); break} if (c [i] 0) f = i [0]; else {(c in g) için {if (! i [0] || a.converters [g + " "+ i [0]]) {f = g; sonu} d || (d = g)} f = f || d} dönüş f? (f! == i [0] && i.shift (f), c [f]): void 0} işlev Pc (a, b, c, d) {varis, f, g, h, i, j = {}, k = a.dataTypes.slice (); eğer (k [1]) (a dönüştürücülerde g) j [g.toLowerCase ()] = a. dönüştürücü [g]; f = k.shift (); iken (f) eğer (a.responseFields [f] && ( c [a.responseFields [f]] = b) ,! i && d && a.dataFilter &&(b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) eğer ("*" === f) f = i; aksi takdirde ("*"! == i && i! == f) {eğer (g = j [i + "" + f] || j ["*" + f],! g) (e in j) için (h = e.split ("") , h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]]))) {g ===! 0? g = j [ e]: j [e] == 0 && (= h [0], k.unshift (s [1]), f), ara} (g == 0!) (g && bir [ "atar"]! ) b = g (b); {b = g (b)} catch (l) {return {state: "parsererror", hata: g? l: "" + i + "ile" + f} arasında dönüşüm yok }} dönüş {durumu: "başarılı", veriler: b}} m.extend ({aktif: 0, LastModified: {} ETag: {} ajaxSettings: {uRL: zc, türü: "GET", isLocal: Dc .test (yc [1]), global:! 0, processData:! 0, async:! 0, contentType: "uygulama / x-www-form-urlencoded; charset = UTF-8", kabul eder: {"*" : Jc metin: "metin / düz", html: "text / html", xml:"uygulama / xml, metin / xml", json: "uygulama / json, metin / javascript"}, içerik: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml: "responseXML", metin: "responseText", json: "responseJSON"}, dönüştürücüler: {"* text": String, "text html":! 0, "text json": m.parseJSON, "text xml": m .parseXML}, flatOptions: {url:! 0, bağlam:! 0}}, ajaxSetup: function (a, b) {return b? Nc (Nc (a, m.ajaxSettings), b): Nc (m.ajaxSettings) , a)}, ajaxPrefilter: Lc (Hc), ajaxTransport: Lc (Ic), ajax: function (a, b) {"nesne" == bir && (b = a, a = boşluk 0), b = b | | {}; var c, d, e, f, g, h, i, j, k = m.ajaxSetup ({}, b), l = k.context || k, n = k.context && (l. nodeType || l.jquery)? m (l): m.event, o = m.Deferred (), p = m.Callbacks ("bir kez bellek"), q = k.statusCode || {}, r = { }}, t = 0, u = "iptal edildi" {= s, v = {readyState: 0,getResponseHeader: function (a) {var b; eğer (2 === t) {eğer (! j) {j = {}; iken (b = Cc.exec (f)) j [b [1] .toLowerCase ( )] = b [2]} b = j [a.toLowerCase ()]} return null == b? null: b}, getAllResponseHeaders: function () {return 2 === t? f: null}, setRequestHeader: function (a, b) {var c = a.toLowerCase (); return t || (a = s [c] = s [c] || a, r [a] = b), bu}, overrideMimeType: function (a) {return t || (k.mimeType = a), bu}, statusCode: function (a) {var b; eğer (a) eğer (2> t) için (b içinde a) q [b] = [q [b], a [b]]; else v.always (a [v.status]); Döndür}, abort: function (a) {var b = a || u; return i && i.abort (b ) x (0, b), bu}}, eğer (o.promise (v) .complete = p.add, v.success = v.done, v.error = v.fail, k.url = (( bir || k.url || zc) + ""). (Ac, yerine ""). değiştirin (Fc, yc [1] + ' "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim (k.dataType || "*"). toLowerCase (). eşleme (E) || [ ""], boş == k.crossDomain && (c = KR.exec (k.url.toLowerCase ()), k.crossDomain = (c || c [1] === yc [1] && c [2] === yc [2] && (c [3]! | |? ( "http:" === c [1] "80", "443")) === (yc [3] || ( "http:" === yc [1] "80": "443")))), k.data && k.processData && "string"! = K.data && (k.data = m.param (k.data, k.traditional))), Mc (Hc, k, b, v ), 2 === t) v; h = k.global, h && 0 === m.active ++ && m.event.trigger ("ajaxStart"), k.type = k.type.toUpperCase (), k .hasContent = Ec.test (k.type), e = k.url, k.hasContent || (k.data && (e = k.url + = (wc.test (e) "&":!? "?" ) + k.data, k.data silin), k.cache ===! 1 && (k.url = Bc.test (e)? e.replace (Bc, "$ 1 _ =" + vc ++): e + (wc .test (e) "ve": "?") + "_ =" + vc ++)), k.ifModified && ([e] m.lastModified && v.setRequestHeader (""M.lastModified [e]), m.etag [e] && v.setRequestHeader ( "If-None-Match", m.etag [e])), (k.data && k.hasContent && k.contentType-yana If-Modified ! ==! 1 || b.contentType) && v.setRequestHeader ( "Content-Type", k.contentType), v.setRequestHeader ( "Kabul", k.dataTypes [0] && k.accepts [k.dataTypes [0] ]? k.accepts [k.dataTypes [0]] + ("*"! == k.dataTypes [0]? "," + Jc + "; q = 0.01": ""): k.accepts ["* "]); (k.başında d) v.setRequestHeader (d, k.başlığı [d]); eğer (k.beforeSend && (k.beforeSend.call (l, v, k) ===! 1 | | 2 === t)) v.abort (); u = "abort"; (d {basarısı: 1, hata: 1, tamamlandı: 1}) v [d] (k [d]); (i = Mc (Ic, k, a, b, h)) {v.readyState = 1, h && n.trigger ( "ajaxSend", [v k]), k.async && k.timeout> 0 && (g = setTimeout (fonksiyonu halinde () {v.abort ("zaman aşımı ")}, k.timeout)); deneyin {t = 1, i.send (r, x)} yakala (w) {if (! (2> t)) atmak w; x (-1, w) }} else x (-1, "Transport yok"); fonksiyon x (a, b, c, d) {var j, r, s, u, w, x = b; 2! == t && (t = 2 , g && clearTimeout (g), i = geçersiz 0, f = d || "", v.readyState = a> 0? 4: 0, j = a> = 200 && 300> a || 304 === a, c && (u = Oc (k, h), c), u = PC (k, u, v, j) j? (k.ifModified && (= v.getResponseHeader (w ( "-son tadil edilmiş" && w) m.lastModified [ e] = v.getResponseHeader ( "etag"), ağırlık && (m.etag [e] = w)), w) w = 204 === bir || "kafa" === k.type x =" nocontent ":? 304 === bir x ="! NotModified ":( x = u.state, r = u.data, s = u.error, j = s)) :( s = x (a || ! x) && (x = "hata", 0> bir && (a = 0))), v.status = a, v.statusText = (b || x) + "" j? o.resolveWith (l, l [r, x, v]): o, reddetmek (l, [v, x, s]), v.statusCode (q), q = boşluk 0, h && n.trigger (j? "ajaxSuccess ":" ajaxError", [h, k, J r: s]), p.fireWith (l, l [V, X]), h && (n.trigger ( "ajaxComplete", [v k]), - m.active || m.event.trigger ("ajaxStop")))} return v}, getJSON: function (a, b, c) {return m.get (a, b, c, "json") }, getScript: function (a, b) {return m.get (a, void 0, b, "script")}}), m.each (["get", "post"], işlev (a, b ) {m [b] = fonksiyon (a, c, d, e) {dönüş m.isFunction (c) && (e = e || d, d = c, c = boşluk 0), m.ajax ({url a: b, dataType: e, veriler: c, başarılı: b})}}), m.each ([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess"," ajaxSend "], işlev (a, b) {m.fn [b] = işlev (a) {return this.on (b, a)}}), m._evalUrl = işlev (a) {return m.ajax ( {url: a yazın: "GET", dataType: "script", zaman uyumsuz: 1, küresel: 1, "atar":! 0})}, m.fn.extend ({wrapAll: function (a) {if (m.isFunction (a)) this.each (function (b) {m (this) .wrapAll (a.call (this, b))});) () bu [0]) {var b = m (a, bu [0] .ownerDocument) .eq (0) .clone (! 0); bu [0] .parentNode && b.insertBefore (bu [0]), b.map (function () {var a = this; süre (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; a} döndür.) append (this)} bunu geri döndür}}, wrapInner: function (a) {this.each (m.isFunction (a)? function (b) işlevini {m (bu) .wrapInner (a.call (this, b))}}: işlev () {var b = m (bu), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = m.isFunction (a); (c) {m (bu) .wrapAll (b? a.call (bu, c): a)})}, unwrap: function () {return this.parent (). each (function () {m.nodeName (this, "body") || m (bu) .replaceWith (this.childNodes)}). end ()}}), m.expr.filters.hidden = function (a) {return a.offsetWidth <= 0 && a .offsetHeight <= 0 ||! k.reliableHiddenOffsets () && "hiçbiri" === (a.style && a.style.display || m.css (a, "ekran"))}, m.expr.filters.visible = işlev (a) {return! m.expr.filters.hidden (a)}; var Qc = /% 20 / g, Rc = / \ [\] $ /, Sc = / \ r? \ n / g, Tc = / ^ (?: gönder | button | image | reset | file) $ / i, Uc = / ^ (?: input | select | textarea | keygen) / i; function Vc (a, b, c, d) { var e; eğer (m.isArray (b)) m.each (b, fonksiyon (b, e) {c || Rc.test (a)? d (a, e): Vc (a + "[" + ( "object" == e? b: "") + "]", e, c, d)}); aksi halde (c || "object"! == m.type (b)) d (a, b); (b'de e) yerine Vc (a + "[" + e + "]", b [e], c, d)} m.param = fonksiyon (a, b) {var c, d = [] e = fonksiyonu (a, b) {b = m.isFunction (b) b ():? boş == b "" b, d [d.length] = encodeURIComponent (a) + "=" + encodeURIComponent (b)}; eğer (geçersiz 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray (a) || a.jquery &&! m.isPlainObject (a)) m.each (a, function () {e (this.name, this.value)}); , bir [c], b, e); dönüş d.join ("&"). değiştir (Qc, "+")}, m.fn.extend ({serialize: function () {return m.param (this .serializeArray ())}, serializeArray: function () {return this.map (function () {var a = m.prop (this, "elements"); bir? m.makeArray (a): this}) döndürün. filter (function () {var a = this.type; this.name döndürün &&! m (this) .is (": disabled") && Uc.test (this.nodeName) &&! Tc.test (a) && (this. işaretlenmiş ||! W.test (a))}). map (işlev (a, b) {var c = m (bu) .val (); return null == c? null: m.isArray (c)? m.map (c, olan (a) {dönüş {adı: b.name, değeri: a.replace (Sc, "\ r \ n")}}): {adı: b.name, değeri: c.replace (Sc, "\ r \ n")}}). Get ()}}), m.ajaxSettings.xhr = void 0! == a.ActiveXObject? Function () {this!isLocal && / ^ (get | post | head | put | delete | options) $ / i.test (this.type) && Zc () || $ c ()}: Zc; var Wc = 0, Xc = {}, Yc = m.ajaxSettings.xhr (); a.ActiveXObject && m (a) .on ("unload", function () {için (Xc'de bir var) Xc [a] (geçersiz 0,! 0)}), k.cors = !! Yc && "withCredentials", Yc, Yc = k.ajax = !! Yc, Yc && m.ajaxTransport (işlev (a) {if (! A.crossDomain || k.cors) {var b; return {send: function (c, d) {var e, f = a.xhr (), g = ++ Wc; eğer (f.open (a.type, a.url, a.async, a.username, a.password), a.xhrFields) (e.xhrFields içinde) f [e] = a.xhrFields [e]; a.mimeType && f.overrideMimeType && f.overrideMimeType (a.mimeType), a.crossDomain || c ["X-Requested-With "] || (c [" X-Requested-With "] =" XMLHttpRequest "); (e in c) boşluğu için 0! == c [e] && f.setRequestHeader (e, c [e] +" ")) ; f.send (a.hasContent && a.data || null), b = fonksiyon (c, e) {var h,i, j; eğer (b && (e || 4 === f.readyState)) eğer (Xc [g] sil, b = geçersiz 0, f.onreadystatechange = m.noop, e) 4! == f.readyState && f .abort (); else {j = {}, h = f.status, "string" == typ.f.responseText && (j.text = f.responseText); deneyin {i = f.statusText} catch (k) { i = ""} h || a.isLocal || a.crossDomain 1223 === h && (h = 204):! H = j.text 200: 404} j && D (h, i, j, f.getAllResponseHeaders ())}, a.async? 4 === f.readyState? setTimeout (b): f.onreadystatechange = Xc [g] = b: b ()}, iptal et: function () {b && b (geçersiz 0 ,! 0)}}}}); işlev Zc () {try {deneyin {return yeni a.XMLHttpRequest} catch (b) {}} işlev $ c () {deneyin {return yeni a.ActiveXObject ("Microsoft.XMLHTTP")} catch (b) {}} m.ajaxSetup ({accept: {script: "text / javascript, uygulama / javascript, uygulama / ecmascript, application / x-ecmascript"}, içerik: {script: / (?: java | ecma) script /}, dönüştürücüler: {"text script":işlevi (a) {return m.globalEval (a), a}}}), m.ajaxPrefilter ("script", işlev (a) {void 0 === a.cache && (a.cache =! 1), a .crossDomain && (a.type = "GET", a.global =! 1)}), m.ajaxTransport ("script", fonksiyon (a) {if (a.crossDomain) {var b, c = y.head | | m ( "kafa") [0] || y.documentElement; dönüş {göndermek: = y.createElement b fonksiyonu (d, e) {( "komut"), b.async = 0, a.scriptCharset && (b .charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = fonksiyonu (a, c) {(c || b.readyState || / yüklü |! tam / .test (b .readyState)) && (b.onload = b.onreadystatechange = sıfır, b.parentNode && b.parentNode.removeChild, (b), b = sıfır, c || e (200, "başarılı"))}, c.insertBefore (b , c.firstChild)}, abort: function () {b && b.onload (void 0,! 0)}}}}); var _c = [], ad = / (()) \? (? = & | $) | \ \ /; m.ajaxSetup ({jsonp:? "geri",jsonpCallback: function () {var a = _c.pop () || m.expando + "_" + vc ++; şunu döndürün [a] =! 0, a}}), m.ajaxPrefilter ("json jsonp", function ( b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (ad.test (b.url)? "url": "string" == b.data &&! (b .contentType || ""). indexOf ("application / x-www-form-urlencoded") && ad.test (b.data) && "data"); h döndürün || "jsonp" === b.dataTypes [ ? 0] (e = b.jsonpCallback = m.isFunction (b.jsonpCallback) b.jsonpCallback (): b.jsonpCallback, H B [h] = b [h] .Kapağı (reklam, "$ 1" + e ):! b.jsonp == 1 && (b.url + = (wc.test (b.url) "&":? "?")! + b.jsonp + "=" + e) ​​b.converters [ "senaryo json "] = function () {return g || m.error (e +" denmedi "), g [0]}, b.dataTypes [0] =" json ", f = a [e], a [ e] = fonksiyonu () {g = argümanlar}, d.Her zaman (fonksiyonu () bir {[e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, _c.push (e)), g && m.isFunction (f) && f (g [0]), g = f = void 0}), "script"): void 0}), m.parseHTML = function (a, b, c) {if (! a || "string"! = typeof a) return null; "boolean "== b && (c = b, b =! 1), b = b || y; var d = u.exec (a), e =! c && []; return d? [b.createElement (d [ 1])] :( d = m.buildFragment ([a], b, e), e && e.ongth && m (e) .remove (), m.merge ([], d.childNodes))}}; var bd = m .fn.load; m.fn.load = function (a, b, c) {if ("string"! = bir && bd yazın) bd.apply (this, argümanlar); var d, e, f, g = this , h = a.indexOf (""); dönüş h> = 0 && (d = m.trim (a.slice (h, a.length))), a = a.slice (0, h)), m.isFunction (b)? (c = b, b = geçersiz 0): b && "nesne" == b && (f = "POST"), g.length> 0 && m.ajax ({url: a, type: f, dataType:"Html" veriler: b.}) Tamam (fonksiyon, (a) {e = argümanlar, g.html (md, ( "<div>") (m.parseHTML (a)), arayan ekleme (d) '?.. : a.)}) tam (c && fonksiyonu (a, b) {g.each (c, e || [a.responseText, b, e])}), bu} m.expr.filters.animated = fonksiyonu ( a) {return m.grep (m. zamanlayıcılar, fonksiyon (b) {return a === b.elem}). uzunluk}; var cd = a.document.documentElement; function dd (a) {return m.isWindow (a)? a: 9 === a.nodeType? a.defaultView || a.parentWindow:! 1} m.offset = {setOffset: function (a, b, c) {var d, e, f, g , h, i, j, k = m.css (a, "konum"), i = m (a) n = {}; "statik" === k && (a.style.position = "nispi") f = m.css h = l.offset (), (a, "üst"), i = m.css (a, "sol"), j = ( "mutlak" === k || "sabit" === k) && m.inArray ( "otomatik", [f, i])> -? 1, j (d = l.position () g = d.top e = d.left) :( c = parseFloat (f) || 0, e = parseFloat (i) '|| 0), m.isFunction (b)Ve (b = b.call (a, c, h)) boş! = B.top && (n.top = b.top-h.top + g), sıfır! = B.left && (n.left = B .left-h.left + e), b? b.using.call (a, n) 'da "kullanma": l.css (n)}}, m.fn.extend ({offset: function (a) { if (arguments.length), void 0 === a? this: this.each (function (b) {m.offset.setOffset (this, a, b)}) döndürür; var b, c, d = {top: 0, sol: 0}, e = bu [0], f = e && e.ownerDocument; (f) döndürürse b = f.documentElement, m.contains (b, e)? (Typ.e e.getBoundingClientRect! == K && ( d = e.getBoundingClientRect ()), = aa c (f) {En: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), sol: d.left + (c. pageXOffset || b.scrollLeft) - (b.clientLeft || 0)}): d}, position: function () {eğer (bu [0]) {var, a, b, c = {üst: 0, sol: 0}, d = bu [0];? dönüş "sabit" === m.css (d, "pozisyonu"), b = d.getBoundingClientRect () :( a = this.offsetParent (), b = this.offset (), m.nodeName (a [0], "html") || (c = a.offset ()), c.top + = m.CSS (a [0], "borderTopWidth", 0!), c.left + = m.css (a [0], "borderLeftWidth", 0!)), {en: b.top-c.top m. css (d, "marginTop",! 0), solda: b.left-c.left-m.css (d, "marginLeft",! 0)}}}, offsetParent: function () {return this.map ( function () {var a = this.offsetParent || cd; while (a &&! m.nodeName (a, "html") && "statik" === m.css (a, "position")) a = a. offsetParent; bir || cd})}}), m.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, işlev (a, b) {var c = / Y / .test (b); m.fn [a] = işlev (d) {dönüş V (bu, işlev (a, d, e) {var f = dd (a); dönüş boşluğu 0 === e? f? b f? f [ b]: f.document.documentElement [d]: bir [d]:? void (ön f.scrollTo (c m (f) .scrollLeft (): e, c e: m (f) .scrollTop () ): a [D] = e)}, a, D, arguments.length, boş)}}), m.each ([ "üst", "sol"], fonksiyon (a, b) {m.cssHooks [ b] = Lb (k.pixelPosition,işlevi (a, c) {return c? (c = Jb (a, b), Hb.test (c)? m (a) .position () [b] + "px": c): geçersiz 0}) }), m.each ({Yükseklik: "yükseklik", En: "genişlik"} fonksiyonu (a, b) {m.each ({doldurma "iç", + a içeriği: b: "" "dış "+ a}, işlev (c, d) {m.fn [d] = işlev (d, e) {var f = arguments.length && (c ||" boolean "! = d = t), g = c || (d ===! 0 || e ===! 0? "marj": "sınır"); V değerini döndür (bu, fonksiyon (b, c, d) {var e; m.isWindow (b)? b.document.documentElement [ "müşteri" + a]: 9 === b.nodeType (e = b.documentElement, Math.max (b.body, e [+ a "kaydırma"] [ "kaydırma" + bir ], b.body ["ofset" + a], e ["offset" + a], e ["müşteri" + a])): geçersiz 0 === d? m.css (b, c, g) : m.style (b, c, d, g)}, b, f? d: void 0, f, null)}})}), m.fn.size = function () {return this.length}, m.fn.andSelf = m.fn.addBack, "fonksiyon"== typeof define && define.amd && define ("jquery", [], function () {return m}); var ed = a.jQuery, fd = a. $; return m.noConflict = function (b) {return a. $ === m && (a. $ = fd), b && a.jQuery === m && (a.jQuery = ed), m}, typeof b === K && (a.jQuery = a. $ = m), m} );